<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Research on Transport Control and Flow Scheduling in Low-latency Datacenter Networks</title>
      <link href="/2020/08/08/PaperReading/Research-on-Transport-Control-and-Flow-Scheduling-in-Low-latency-Datacenter-Networks/"/>
      <url>/2020/08/08/PaperReading/Research-on-Transport-Control-and-Flow-Scheduling-in-Low-latency-Datacenter-Networks/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="第一章-引言"><a href="#第一章-引言" class="headerlink" title="第一章 引言"></a>第一章 引言</h1><ul><li>数据中心应用类型</li><li>数据中心流量特性</li><li>仍存在的问题</li></ul><p><img src="https://images.weserv.nl/?url=https://gitee.com/HesyH/Image-Hosting/raw/master/image4typora/202008/08/214444-685710.png" alt="image-20200808214442717"></p><p>说实话感觉这里讲的不是很清楚，回头再来仔细梳理下把。</p><h1 id="第二章-背景和相关综述"><a href="#第二章-背景和相关综述" class="headerlink" title="第二章 背景和相关综述"></a>第二章 背景和相关综述</h1><ul><li>传统TCP及研究进展<ul><li>调整AIMD参数 –》good idea ==但是还是那个问题，为什么要搞pacing，而放弃窗口==</li><li>==incast 难道是数据中心特有的问题?== 其实只要BDP足够小就可以把？RTT不够小，但是我bandwidth够小总可以吧？TCP incast不就是拥塞么?<ul><li>我感觉只要是低延迟链路，就会有这种情况 （一旦有超时发生， 网络中会出现长时间的链路闲置状态）</li><li>如果要在数据中心做，得考虑放弃短流的调度，只调度长流？看看iroko怎么做的？</li></ul></li><li>DCTCP是解决TCP incast的？？</li></ul></li></ul><ul><li><p>TCP incast</p><ul><li><p>以前的解决方案</p><blockquote><p>第一类的主要方法是修改TCP配置参数，将RTO设置为微秒级 别，从而减小超时重传所需的等待时间; 第二类为修改TCP的拥塞控制算法，提高 缓存利用率，进而避免丢包；第三类是通过修改QCN算法来提高协议公平性；第 四类摒弃 TCP 方案采用 UDP 方案彻底避免超时重传的问题。</p></blockquote></li></ul></li><li><p>多种流量共存</p><ul><li><p>长流(重视高吞吐) &amp; 短流(重视低延迟) –》 目标不同</p></li><li><p>相互作用：长流容易造成短流的饥饿</p></li><li><p>还有部分应用存在截止时间需求 ，whose 主要性能指标是截止时间错过率</p></li><li><p>应对措施</p><blockquote><p>非截止时间流调度机制和传输协议研究，截止时间流调度机制 和传输协议研究和混合流调度机制和传输协议研</p></blockquote></li></ul></li><li><p>任务调度</p></li></ul><p><img src="https://images.weserv.nl/?url=https://gitee.com/HesyH/Image-Hosting/raw/master/image4typora/202008/09/154827-641523.png" alt="image-20200809154826511"></p><h1 id="第三章-支持选择性反馈的编码传输协议研究研究"><a href="#第三章-支持选择性反馈的编码传输协议研究研究" class="headerlink" title="第三章 支持选择性反馈的编码传输协议研究研究"></a>第三章 支持选择性反馈的编码传输协议研究研究</h1><ul><li>关于发送速率，on friendliness ，需要做的是：找论文背书，基于别人的公式进行建模</li></ul><h1 id="第四章-数据中心网络的混合流调度机制SMF"><a href="#第四章-数据中心网络的混合流调度机制SMF" class="headerlink" title="第四章 数据中心网络的混合流调度机制SMF"></a>第四章 数据中心网络的混合流调度机制SMF</h1><blockquote><p>这一部分讲的比较详细</p></blockquote><h2 id="miscelleneous"><a href="#miscelleneous" class="headerlink" title="miscelleneous"></a>miscelleneous</h2><ul><li>如何判断截止时间流还有非截止时间流本身也是个很大的问题啊！</li><li>传统解决方案中，基于速率的控制协议（RCP）到底是什么呢？Karuna采用的MCP又是什么呢?</li></ul><h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><ul><li><p>SMF</p><ul><li>对于非截止事件流，采用SJF</li><li>对于截止事件流，采用MLFQ</li><li>是满足多重目标的分布式拥塞控制协议，旨在调度混合流以改善流完成率和流完成时间</li><li>也对初始窗口大小做了改进，where也很重要。裴丹的，实际上是根据具体的业务进行改进了的。看看SMF采取了哪些feature，怎么做的，或许也是一个点？</li></ul></li><li><p>NP-hard问题证明</p><ul><li>截止时间流</li><li>非截止时间流（ 感觉讲得也很粗糙</li><li>所以使用启发式</li></ul></li><li><p>对于不能在截止时间前完成的流，<strong>“早丢弃”</strong>方式提前丢弃以节省网络带宽</p><ul><li>==自己的机制里面如果太简单，也可以加一些“早丢弃”等手工的规则==</li></ul></li><li><p>考察指标</p></li></ul><img src="C:\Users\hesy\AppData\Roaming\Typora\typora-user-images\image-20200809171054378.png" alt="image-20200809171054378" style="zoom: 80%;" /><h1 id="第五章-任务级别的截止时间感知流调度机制研究TAPS"><a href="#第五章-任务级别的截止时间感知流调度机制研究TAPS" class="headerlink" title="第五章 任务级别的截止时间感知流调度机制研究TAPS"></a>第五章 任务级别的截止时间感知流调度机制研究TAPS</h1><h2 id="重要性"><a href="#重要性" class="headerlink" title="重要性"></a>重要性</h2><ul><li><p>如果某任务没有在截止事件前完成，那么该任务已经成功传输完成的所有数据都是无用数据。非常不幸的是，数据中心网络中采用的大部分传输协议，都是基于竞争的传输协议，如 TCP，RCP[35]，ICTCP[10]，DCTCP[2]，采用平均分配带宽的原则为网络中互相竞争的每条流分配链路以及可用带宽。这些方案固然可以有效将数据流从源端传输到目的端，但是他们忽略了数据流或是任务的截止时间，同时也没有意识到不同流之间的区别，无法做到最小化网络流完成时间。</p></li><li><p>统计数据表明，对于 web 应用，每个任务至少包括 88 条流[2]，对于 MapReduce 搜索工作每个任务包含 30 到 50000 条流[6]，对于 Cosmos 每个任务约包含 30 到 70 条流[97]。这些统计数据表明在数据中心内，很多应用对于每个任务会产生相应的多条数据流来完成，因此任务才是处理的单位。</p></li></ul><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>使用SDN</p>]]></content>
      
      
      <categories>
          
          <category> PaperReading </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Network </tag>
            
            <tag> Congestion Control </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python总结</title>
      <link href="/2020/08/08/Summary/python/"/>
      <url>/2020/08/08/Summary/python/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="深浅拷贝"><a href="#深浅拷贝" class="headerlink" title="深浅拷贝"></a>深浅拷贝</h1><ul><li>说千道万，不如<span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMWNjNDExaDdoZD9mcm9tPXNlYXJjaCZzZWlkPTE3OTE4NDE2ODkwNDkxMDIzMzY=">画图实在<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbG9sZWluYS9wLzUyNzY5MTguaHRtbA==">函数传参，传的是引用<i class="fa fa-external-link-alt"></i></span><blockquote><p>Python参数传递采用的肯定是“传对象引用”的方式。这种方式相当于传值和传引用的一种综合。如果函数收到的是一个<strong>可变对象（比如字典或者列表）</strong>的引用，就能修改对象的原始值－－相当于通过“传引用”来传递对象。如果函数收到的是一个<strong>不可变对象（比如int、str或者tuple</strong>）的引用，就不能直接修改原始对象－－相当于通过“传值’来传递对象。 </p><blockquote><p> 注意，tuple本身不可变，但是tuple里面的元素可变</p></blockquote></blockquote></li></ul><h1 id="闭包-amp-nonlocal"><a href="#闭包-amp-nonlocal" class="headerlink" title="闭包 &amp; nonlocal"></a>闭包 &amp; nonlocal</h1><ul><li><a href="nonlocal">nonlocal</a></li><li><span class="exturl" data-url="aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAwNDQ2MTQwNA==">闭包<i class="fa fa-external-link-alt"></i></span><ul><li>其中几个作用：节省开销，将函数与某个参数绑定</li><li>装饰器就是一种闭包</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> Summary </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CC常识记录</title>
      <link href="/2020/08/07/Summary/CC%E5%B8%B8%E8%AF%86%E8%AE%B0%E5%BD%95/"/>
      <url>/2020/08/07/Summary/CC%E5%B8%B8%E8%AF%86%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuc3ByaW50Lm5ldC9zbGFfcGVyZm9ybWFuY2UucGhwP25ldHdvcms9c2w=">Sprint.net中统计的网络性能参数<i class="fa fa-external-link-alt"></i></span> </li><li>rtt普通情况下也就0.1s【CUBIC论文中写的】<ul><li>BBR论文中表示，由于buffer是BDP的几个数量级，所以rtt从毫秒级别变成了秒级</li></ul></li></ul><h1 id="pacing"><a href="#pacing" class="headerlink" title="pacing"></a>pacing</h1><ul><li>TCP的流控机制，基本上是有两种的，专业一点的说法分别叫做pure rate control和windows-based这两种<ul><li>pure rate control <ul><li>告诉你sender一个发送速率(bottleneck bandwidth)，sender的发送速率不超过这个确定值。</li></ul></li><li>window-based control<ul><li>这个就是常见的TCP 滑动窗口的协议，就是有一个ack确认后我才能发送下面的。</li></ul></li><li>pacing结合了这两种<ul><li>uses the tcp window to determine how much to send but uses rates instead of acknowledgments to determine when to send.</li><li>为什么要这样，因为标准TCP的发包是back-to-back的,TCP的这种clumped方式会引发高延迟以及burst traffic下的丢包大大增加，同时还有ACK Compression，Multiplexing等各种问题都会导致性能受损，所以有人突出了一个机制，我们能不能不让包堆在一起发，在一个窗口里流出间隔，那我们的排队队长就会下降的。</li><li>pacing可以看作TCP的一个变体，是结合了上面的两个流控方式，他使用tcp window决定发多少,用bottleneck bandwidth决定什么时候发，它定义了一个发包的间隔</li></ul></li><li>paing需要优化嘛？需要。 更多的可以看这个<span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zMDc0MTA3Mw==">专栏<i class="fa fa-external-link-alt"></i></span>搜集的paper  </li></ul></li></ul><h1 id="How-can-we-be-aware-of-congestion"><a href="#How-can-we-be-aware-of-congestion" class="headerlink" title="How can we be aware of congestion"></a>How can we be aware of congestion</h1><ul><li><p>the internet is a <strong><code>decentralized</code></strong> system, and as a result of that, doesn’t have any central coordinator telling senders to slow down if link queues downstream of some sender are filling up.</p></li><li><p>There are two main indicators: <strong><code>packet loss</code></strong> and increased  <strong><code>round trip times</code></strong>  for packets. </p><ul><li><p>If a sender notices packet loss, it’s a pretty good indicator that congestion is occuring. </p></li><li><p>Another consequence of queues filling up though is that if packets are spending more time in a queue before making it onto the link, the round trip time, which measures the time from when the sender sends a segment out to the time that it receives an acknowledgement, will increase.</p><blockquote><p>summary：可以通过 <strong>packet loss</strong> 和 <strong>RTT</strong> 这两个现象来观察是否有congestion</p></blockquote></li></ul></li></ul><h1 id="sending-rate-amp-delivery-rate"><a href="#sending-rate-amp-delivery-rate" class="headerlink" title="sending rate &amp; delivery rate"></a>sending rate &amp; delivery rate</h1><ul><li>sending rate就是发送速率</li><li>delivery rate强调接收方收到的包的速率（你发出去但是人家不一定能收到不是</li></ul><h1 id="ACK-compression"><a href="#ACK-compression" class="headerlink" title="ACK compression"></a>ACK compression</h1><ul><li>由于中间链路的缓存以及和其他TCP连接一起共享缓存等原因，可能会导致ACK报文成堆到达发送端。这种场景我们就称呼为ACK压缩。</li><li>i.e. 一个TCP发送者的 自计时取决于到来的，由接收机按照相同时间间隔生成的ACK。如果这些的ACK通过网络过境期间存在一些开销在队列中，但是，它们的间隔可能会改变。当ACK的到达间距小于它们发送的间距，发送者可能会被误导，发送比网络可以接受的更多的数据，这可能导致堵塞和效率损失。</li><li>于ACK compression场景，reno拥塞控制就是逐个处理每个ACK报文，这样就会导致拥塞窗口突然增大，发送端突然发出大量的TCP报文，这种突然发出大量数据的行为我们称呼为burst，影响网络平稳。另外一方面ACK compression还会影响RTT估计，之前我们介绍过有些拥塞控制算法基于时延来来估计网络拥塞情况，因此 ACK compresion还会影响这类基于时延的拥塞控制算法的性能。</li></ul><h1 id="做CC实验要注意的点"><a href="#做CC实验要注意的点" class="headerlink" title="做CC实验要注意的点"></a>做CC实验要注意的点</h1><ul><li>不仅要测拥塞程度是否改进了</li><li>还要测量收敛速度和fairness to existing congestion control protocols</li></ul><h1 id="数据中心的CC"><a href="#数据中心的CC" class="headerlink" title="数据中心的CC"></a>数据中心的CC</h1><h2 id="learn-from-Lili-Liu’s-paper"><a href="#learn-from-Lili-Liu’s-paper" class="headerlink" title="learn from Lili Liu’s paper"></a>learn from Lili Liu’s paper</h2><ul><li><p>一般<strong>低延迟应用</strong>的流<strong>的 SLA</strong> (Service Level Agreement)要求是 300ms 内完成</p></li><li><p><strong>研究TCP</strong>（而不是一些基于UDP协议）<strong>的重要性</strong> （ 请注意，quic只是实现的一个途径–》用户态 ）</p><ul><li><p>数据中心要求可靠性，目前实现数据中心间的可靠传输的唯一途径是TCP</p><blockquote><p>数据中心间的链路是由 ISP 提供带宽和时延保障的专用链路，但由于路由切换及一 些突发事件，这种专用链路上偶尔也会发生丢包 </p></blockquote><p>根据 ISP 与服务商的SLA，<strong>丢包率一般在 0.5% 到 5% 之间，时延一般不超过 20ms</strong>。</p></li><li><p>研究结果表明数据中心网络中99%的流量都是TCP流量[2]</p><blockquote><p>参考文献[2]是一个2010年的文章</p></blockquote></li><li><p>然而，数据中心网络的传输协议大多数都采用TCP，<strong>并使用平均分配带宽为原则</strong>，将网络资源平均分配。如此做的方案主要有**<u>TCP、RCP[35]、DCTCP和HULL[18]等</u>**</p></li></ul></li><li><p>诸多研究表明<strong>TCP RTO是导致TCP Incast</strong> 的主要原因</p><ul><li>在 TCP 中，默认超时重传计时器 $RTO_min$ 为 200ms，数据中心网络正常 RTT 通常为 200µs</li></ul></li><li><p>数据中心网络传输协议近年来<strong>主要面临的问题</strong>有：</p><ul><li>TCP Incast 问题</li><li>低延迟、高吞吐性能需求</li><li>多任务模式等（对于FCT有要求）</li></ul></li><li><p>最近发表的一个研究([3])表明，网络中由于低效的链路带宽利用率，平均<strong>有 7.25% 的数据流未能在截止时间前完成</strong>。</p></li><li><p>TCP的设计采用平<strong>均分配带宽原则</strong></p></li><li><p><strong>截止时间流和非截止时间流</strong></p><ul><li>尽管数据中心网络中<strong>有截止时间流</strong>所占比率很低，大概是所有流量的 5%。</li><li><strong>非截止时间流</strong>的应用彼此不同。有些应用像 VM 迁移或者数据备份等，在传输开始前就可以得知该流的大小，然而对于一些像数据库存取和 HTTP 分块传输的应用，这些应用在他们传输开始之前不知道流大小或者截止时间相关信息。<ul><li>因此，对于非截止时间流，较短的流完成时间和较高的吞吐率是他们的<strong>主要性能指标</strong>。</li></ul></li></ul></li></ul><h1 id="HULL"><a href="#HULL" class="headerlink" title="HULL"></a>HULL</h1><ul><li>high-performance ultra-low latency</li><li>他从三个层次来进行了设计：<ul><li>Phantom queues: Detecting and signaling congestion<ul><li>这个机制是一种为了创建剩余buffer提出的一种机制，也就是我们常说的bandwidth headroom，通过减少长流带宽来获取更高的短流效率，在端口使用仿真的虚拟队列基于链路利用率而不是利用队列的占有率来设计ECN标记。</li></ul></li><li>DCTCP: Adaptive reaction to ECN</li><li>Packet pacing<ul><li>这个在前面的文章里面也讲了Pacing的实现原理，但是我们也分析过Pacing其实不一定会带来特别好的效果，是有一定条件的，所以这篇文章用了一个硬件pacer，感觉很厉害。但是本质还是按照固定间隔发送封包。</li></ul></li></ul></li></ul><h1 id="some-resources（博客资源-and-so-on）"><a href="#some-resources（博客资源-and-so-on）" class="headerlink" title="some resources（博客资源 and so on）"></a>some resources（博客资源 and so on）</h1><p><span class="exturl" data-url="aHR0cHM6Ly9zcXVpZGFydGguY29tL3JjL3Byb2dyYW1taW5nL25ldHdvcmtpbmcvMjAxOC8wNy8xOC9pbnRyby1jb25nZXN0aW9uLmh0bWw=">squidarth:intro congestion-control<i class="fa fa-external-link-alt"></i></span></p>]]></content>
      
      
      <categories>
          
          <category> Summary </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Network </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>建站 | Jekyll -》 mkdocs -》 hexo</title>
      <link href="/2020/07/30/siteBuilding/"/>
      <url>/2020/07/30/siteBuilding/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="Jekyll"><a href="#Jekyll" class="headerlink" title="Jekyll"></a>Jekyll</h1><p>之前是用的jekyll，但是没找到我想要的全局搜索功能，有兴趣的还是可以看下：<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hlc3lfSC9hcnRpY2xlL2RldGFpbHMvMTA0MTg0NzIw">Jekyll建站<i class="fa fa-external-link-alt"></i></span></p><hr><h1 id="mkdocs"><a href="#mkdocs" class="headerlink" title="mkdocs"></a>mkdocs</h1><blockquote><p>其实Jekyll已经省去了很多麻烦了，但是我真的真的很烦每个md开头要写一大段乱七八糟的配置，不方便迁移，所以就转到mkdocs了，虽然模板的页面效果没有Jekyll丰富，但是对懒人还是极其友好的。</p></blockquote><blockquote><p>本来想用mkdocs的，毕竟还是挺省事儿的，文件结构也很清晰，学神点拨下我发现hexo可以全局搜索，跟mkdocs的标题搜索等级比起来，更香了！<br>简单学了下，后续可能考虑用mkdocs做一些项目文档手册，作为子网址吧，做手册挺合适的。</p></blockquote><h2 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h2><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cueG5jb2RpbmcuY29tLzIwMjAvMDMvMDEvdG9vbC9ta2RvY3MuaHRtbA==">蛮详细的，尤其是关于yml配置文件相关的<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d1dG9uZ3RyZWUuZ2l0aHViLmlvL2Rldm9wcy9tYW5hZ2UteW91ci1jbXMtdXNpbmctbWtkb2Nz">配置也很详细，尤其有一些关于mkdocs的冷知识<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9teS5vc2NoaW5hLm5ldC9menhpYW9tYW5nZS9ibG9nLzMwMTA5MjE=">列了一些注意事项，which我也觉得很重要<i class="fa fa-external-link-alt"></i></span></li><li>这个没仔细看，但是感觉很高贵的样子 <span class="exturl" data-url="aHR0cHM6Ly90b3V0aWFvLmlvL3Bvc3RzL3Q5M2E1Yy9wcmV2aWV3">将 Jupyter 自动发布到 GitHub Pages<i class="fa fa-external-link-alt"></i></span></li></ul><h2 id="配置中遇到的问题"><a href="#配置中遇到的问题" class="headerlink" title="配置中遇到的问题"></a>配置中遇到的问题</h2><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0b25lOTE1OS9hcnRpY2xlL2RldGFpbHMvNzkwNzEzMTY=">py37下字符编码遇到的问题<i class="fa fa-external-link-alt"></i></span></p><hr><h1 id="hexo"><a href="#hexo" class="headerlink" title="hexo"></a>hexo</h1><blockquote><p>我的两个config.xml（_config.next.xml是对应next主题的配置）都做了比较详细的注释，大家改起来也会很方便，欢迎在我的基础上修改！（虽然我本来也就是改学神的 :)</p></blockquote><h2 id="ref-1"><a href="#ref-1" class="headerlink" title="ref"></a>ref</h2><ol><li><p>环境配置请参考：<span class="exturl" data-url="aHR0cHM6Ly9scnNjeS5naXRodWIuaW8vMjAxNy8xMS8xMC9VYnVudHUtR2l0aHViLWlvLWNvbmZpZy1IZXhvLw==">linux下使用hexo建站<i class="fa fa-external-link-alt"></i></span>    </p><blockquote><ul><li>安装的时候提示8.x已经deprecated，所以我按照提示安装了12.x</li><li>在服务器上跑<code>npm install -g hexo-cli</code>等命令的时候，会遇到权限不够，根据提示给sudo就行</li></ul></blockquote></li><li><p>推送过程和基本配置网上已经很多了</p><blockquote><ul><li>next主题的仓库已经过期，我用的是学神给的这个：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RoZW1lLW5leHQvaGV4by10aGVtZS1uZXh0">https://github.com/theme-next/hexo-theme-next<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly90ZGluZy50b3AvYXJjaGl2ZXMvNDJjMzhiMTAuaHRtbA==">next主题的基本设置<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC85NDAzODY4OA==">hexo主题进阶设置<i class="fa fa-external-link-alt"></i></span></li></ul></blockquote></li><li><p>其他trivial的可选功能</p><blockquote><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC9kNjhkZTA2N2VhNzQ=">Hexo添加Disqus评论<i class="fa fa-external-link-alt"></i></span></li><li>hexo添加google-analytic功能 （ 不想做了2333累了</li></ul></blockquote></li></ol><h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><p>hexo new ‘文章标题’<br>hexo new draft<br> hexo clean</p><blockquote><p>清除缓存文件 (db.json) 和已生成的静态文件 (public)。在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。</p></blockquote><p>hexo g<br>hexo s<br>hexo d</p><hr><h1 id="mkdown-图床-获取-永久链接-（-香"><a href="#mkdown-图床-获取-永久链接-（-香" class="headerlink" title="mkdown+图床 获取 永久链接 （ 香"></a>mkdown+图床 获取 永久链接 （ 香</h1><p>可以参考<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hlc3lfSC9hcnRpY2xlL2RldGFpbHMvMTA3NjIyMjAy">我之前写的文章：typora+gitee图床<i class="fa fa-external-link-alt"></i></span></p><hr><h1 id="Actions"><a href="#Actions" class="headerlink" title="Actions"></a>Actions</h1><ul><li><input checked="" disabled="" type="checkbox"> <span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81YzQxN2RhNzUxODgyNTI1YzYzODA5Y2Q=">简单入个门<i class="fa fa-external-link-alt"></i></span></li><li><input checked="" disabled="" type="checkbox"> <span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC82ODU0NTczMjE4Nzc5MzgxNzcz">hexo+Actions保姆教程<i class="fa fa-external-link-alt"></i></span></li></ul><p>本来想自己写的，结果学神也用的actions，哈哈作业一抄到底 （ docker确实不太精通啊…  - -||| ）</p><hr><h1 id="miscelleous"><a href="#miscelleous" class="headerlink" title="miscelleous"></a>miscelleous</h1><ul><li><input disabled="" type="checkbox"> 添加多个部署源<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">deploy</span>:</span><br><span class="line">- <span class="attribute">type</span>: git</span><br><span class="line">  <span class="attribute">repo</span>:</span><br><span class="line">- <span class="attribute">type</span>: heroku</span><br><span class="line">  <span class="attribute">repo</span>:</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 程序员的自我修养 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tool </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
