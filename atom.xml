<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hesy&#39;s Blog</title>
  
  <subtitle>Seek for your love</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-08-08T15:22:56.574Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Hesy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Research on Transport Control and Flow Scheduling in Low-latency Datacenter Networks</title>
    <link href="http://yoursite.com/2020/08/08/PaperReading/Research-on-Transport-Control-and-Flow-Scheduling-in-Low-latency-Datacenter-Networks/"/>
    <id>http://yoursite.com/2020/08/08/PaperReading/Research-on-Transport-Control-and-Flow-Scheduling-in-Low-latency-Datacenter-Networks/</id>
    <published>2020-08-08T21:39:43.000Z</published>
    <updated>2020-08-08T15:22:56.574Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="第一章-引言"><a href="#第一章-引言" class="headerlink" title="第一章 引言"></a>第一章 引言</h1><ul><li>数据中心应用类型</li><li>数据中心流量特性</li><li>仍存在的问题</li></ul><p><img src="https://images.weserv.nl/?url=https://gitee.com/HesyH/Image-Hosting/raw/master/image4typora/202008/08/214444-685710.png" alt="image-20200808214442717"></p><p>说实话感觉这里讲的不是很清楚，回头再来仔细梳理下把。</p><h1 id="第二章-背景和相关综述"><a href="#第二章-背景和相关综述" class="headerlink" title="第二章 背景和相关综述"></a>第二章 背景和相关综述</h1><ul><li>传统TCP及研究进展<ul><li>调整AIMD参数 –》good idea ==但是还是那个问题，为什么要搞pacing，而放弃窗口==</li><li>==incast 难道是数据中心特有的问题?== 其实只要BDP足够小就可以把？RTT不够小，但是我bandwidth够小总可以吧？</li><li>DCTCP是解决TCP incast的？？</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      data center TCP congestion control ， 做了三方面的工作
    
    </summary>
    
    
      <category term="PaperReading" scheme="http://yoursite.com/categories/PaperReading/"/>
    
    
      <category term="Network" scheme="http://yoursite.com/tags/Network/"/>
    
      <category term="Congestion Control" scheme="http://yoursite.com/tags/Congestion-Control/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://yoursite.com/2020/08/08/Summary/python/"/>
    <id>http://yoursite.com/2020/08/08/Summary/python/</id>
    <published>2020-08-08T15:22:56.574Z</published>
    <updated>2020-08-08T15:22:56.574Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>-–</p><p>title: python总结</p><p>top: false</p><p>cover: false</p><p>toc: true</p><p>mathjax: true</p><p>date: 2020-08-08 17:35:17</p><p>categories: Summary</p><p>description: 关于python的总结</p><p>tags:</p><p>  - Network</p><p>-–</p><h1 id="深浅拷贝"><a href="#深浅拷贝" class="headerlink" title="深浅拷贝"></a>深浅拷贝</h1><ul><li>说千道万，不如<span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMWNjNDExaDdoZD9mcm9tPXNlYXJjaCZzZWlkPTE3OTE4NDE2ODkwNDkxMDIzMzY=">画图实在<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbG9sZWluYS9wLzUyNzY5MTguaHRtbA==">函数传参，传的是引用<i class="fa fa-external-link-alt"></i></span><blockquote><p>Python参数传递采用的肯定是“传对象引用”的方式。这种方式相当于传值和传引用的一种综合。如果函数收到的是一个<strong>可变对象（比如字典或者列表）</strong>的引用，就能修改对象的原始值－－相当于通过“传引用”来传递对象。如果函数收到的是一个<strong>不可变对象（比如int、str或者tuple</strong>）的引用，就不能直接修改原始对象－－相当于通过“传值’来传递对象。 </p><blockquote><p> 注意，tuple本身不可变，但是tuple里面的元素可变</p></blockquote></blockquote></li></ul><h1 id="闭包-amp-nonlocal"><a href="#闭包-amp-nonlocal" class="headerlink" title="闭包 &amp; nonlocal"></a>闭包 &amp; nonlocal</h1><ul><li><a href="nonlocal">nonlocal</a></li><li><span class="exturl" data-url="aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAwNDQ2MTQwNA==">闭包<i class="fa fa-external-link-alt"></i></span><ul><li>其中几个作用：节省开销，将函数与某个参数绑定</li><li>装饰器就是一种闭包</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css&quot;&gt;&lt;p&gt;-–&lt;/p&gt;
&lt;p&gt;title: python总结&lt;/p&gt;
&lt;p&gt;top: 
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>CC常识记录</title>
    <link href="http://yoursite.com/2020/08/07/Summary/CC%E5%B8%B8%E8%AF%86%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2020/08/07/Summary/CC%E5%B8%B8%E8%AF%86%E8%AE%B0%E5%BD%95/</id>
    <published>2020-08-07T22:35:17.000Z</published>
    <updated>2020-08-08T15:22:56.574Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuc3ByaW50Lm5ldC9zbGFfcGVyZm9ybWFuY2UucGhwP25ldHdvcms9c2w=">Sprint.net中统计的网络性能参数<i class="fa fa-external-link-alt"></i></span> </li><li>rtt普通情况下也就0.1s【CUBIC论文中写的】<ul><li>BBR论文中表示，由于buffer是BDP的几个数量级，所以rtt从毫秒级别变成了秒级</li></ul></li></ul><h1 id="pacing"><a href="#pacing" class="headerlink" title="pacing"></a>pacing</h1><ul><li>TCP的流控机制，基本上是有两种的，专业一点的说法分别叫做pure rate control和windows-based这两种<ul><li>pure rate control <ul><li>告诉你sender一个发送速率(bottleneck bandwidth)，sender的发送速率不超过这个确定值。</li></ul></li><li>window-based control<ul><li>这个就是常见的TCP 滑动窗口的协议，就是有一个ack确认后我才能发送下面的。</li></ul></li><li>pacing结合了这两种<ul><li>uses the tcp window to determine how much to send but uses rates instead of acknowledgments to determine when to send.</li><li>为什么要这样，因为标准TCP的发包是back-to-back的,TCP的这种clumped方式会引发高延迟以及burst traffic下的丢包大大增加，同时还有ACK Compression，Multiplexing等各种问题都会导致性能受损，所以有人突出了一个机制，我们能不能不让包堆在一起发，在一个窗口里流出间隔，那我们的排队队长就会下降的。</li><li>pacing可以看作TCP的一个变体，是结合了上面的两个流控方式，他使用tcp window决定发多少,用bottleneck bandwidth决定什么时候发，它定义了一个发包的间隔</li></ul></li><li>paing需要优化嘛？需要。 更多的可以看这个<span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zMDc0MTA3Mw==">专栏<i class="fa fa-external-link-alt"></i></span>搜集的paper  </li></ul></li></ul><h1 id="How-can-we-be-aware-of-congestion"><a href="#How-can-we-be-aware-of-congestion" class="headerlink" title="How can we be aware of congestion"></a>How can we be aware of congestion</h1><ul><li><p>the internet is a <strong><code>decentralized</code></strong> system, and as a result of that, doesn’t have any central coordinator telling senders to slow down if link queues downstream of some sender are filling up.</p></li><li><p>There are two main indicators: <strong><code>packet loss</code></strong> and increased  <strong><code>round trip times</code></strong>  for packets. </p><ul><li><p>If a sender notices packet loss, it’s a pretty good indicator that congestion is occuring. </p></li><li><p>Another consequence of queues filling up though is that if packets are spending more time in a queue before making it onto the link, the round trip time, which measures the time from when the sender sends a segment out to the time that it receives an acknowledgement, will increase.</p><blockquote><p>summary：可以通过 <strong>packet loss</strong> 和 <strong>RTT</strong> 这两个现象来观察是否有congestion</p></blockquote></li></ul></li></ul><h1 id="sending-rate-amp-delivery-rate"><a href="#sending-rate-amp-delivery-rate" class="headerlink" title="sending rate &amp; delivery rate"></a>sending rate &amp; delivery rate</h1><ul><li>sending rate就是发送速率</li><li>delivery rate强调接收方收到的包的速率（你发出去但是人家不一定能收到不是</li></ul><h1 id="ACK-compression"><a href="#ACK-compression" class="headerlink" title="ACK compression"></a>ACK compression</h1><ul><li>由于中间链路的缓存以及和其他TCP连接一起共享缓存等原因，可能会导致ACK报文成堆到达发送端。这种场景我们就称呼为ACK压缩。</li><li>i.e. 一个TCP发送者的 自计时取决于到来的，由接收机按照相同时间间隔生成的ACK。如果这些的ACK通过网络过境期间存在一些开销在队列中，但是，它们的间隔可能会改变。当ACK的到达间距小于它们发送的间距，发送者可能会被误导，发送比网络可以接受的更多的数据，这可能导致堵塞和效率损失。</li><li>于ACK compression场景，reno拥塞控制就是逐个处理每个ACK报文，这样就会导致拥塞窗口突然增大，发送端突然发出大量的TCP报文，这种突然发出大量数据的行为我们称呼为burst，影响网络平稳。另外一方面ACK compression还会影响RTT估计，之前我们介绍过有些拥塞控制算法基于时延来来估计网络拥塞情况，因此 ACK compresion还会影响这类基于时延的拥塞控制算法的性能。</li></ul><h1 id="做CC实验要注意的点"><a href="#做CC实验要注意的点" class="headerlink" title="做CC实验要注意的点"></a>做CC实验要注意的点</h1><ul><li>不仅要测拥塞程度是否改进了</li><li>还要测量收敛速度和fairness to existing congestion control protocols</li></ul><h1 id="数据中心的CC"><a href="#数据中心的CC" class="headerlink" title="数据中心的CC"></a>数据中心的CC</h1><h2 id="learn-from-Lili-Liu’s-paper"><a href="#learn-from-Lili-Liu’s-paper" class="headerlink" title="learn from Lili Liu’s paper"></a>learn from Lili Liu’s paper</h2><ul><li><p>一般<strong>低延迟应用</strong>的流<strong>的 SLA</strong> (Service Level Agreement)要求是 300ms 内完成</p></li><li><p>数据中心要求可靠性，目前实现数据中心间的可靠传输的唯一途径是TCP</p><blockquote><p>数据中心间的链路是由 ISP 提供带宽和时延保障的专用链路，但由于路由切换及一 些突发事件，这种专用链路上偶尔也会发生丢包 </p></blockquote><p>根据 ISP 与服务商的SLA，<strong>丢包率一般在 0.5% 到 5% 之间，时延一般不超过 20ms</strong>。</p></li><li><p>诸多研究表明<strong>TCP RTO是导致TCP Incast</strong> 的主要原因</p><ul><li>在 TCP 中，默认超时重传计时器 $RTO_min$ 为 200ms，数据中心网络正常 RTT 通常为 200µs</li></ul></li><li><p>数据中心网络传输协议近年来<strong>主要面临的问题</strong>有：</p><ul><li>TCP Incast 问题</li><li>低延迟、高吞吐性能需求</li><li>多任务模式等（对于FCT有要求）</li></ul></li><li><p>最近发表的一个研究([3])表明，网络中由于低效的链路带宽利用率，平均<strong>有 7.25% 的数据流未能在截止时间前完成</strong>。</p></li><li><p>TCP的设计采用平<strong>均分配带宽原则</strong></p></li></ul><h1 id="HULL"><a href="#HULL" class="headerlink" title="HULL"></a>HULL</h1><ul><li>high-performance ultra-low latency</li><li>他从三个层次来进行了设计：<ul><li>Phantom queues: Detecting and signaling congestion<ul><li>这个机制是一种为了创建剩余buffer提出的一种机制，也就是我们常说的bandwidth headroom，通过减少长流带宽来获取更高的短流效率，在端口使用仿真的虚拟队列基于链路利用率而不是利用队列的占有率来设计ECN标记。</li></ul></li><li>DCTCP: Adaptive reaction to ECN</li><li>Packet pacing<ul><li>这个在前面的文章里面也讲了Pacing的实现原理，但是我们也分析过Pacing其实不一定会带来特别好的效果，是有一定条件的，所以这篇文章用了一个硬件pacer，感觉很厉害。但是本质还是按照固定间隔发送封包。</li></ul></li></ul></li></ul><h1 id="some-resources（博客资源-and-so-on）"><a href="#some-resources（博客资源-and-so-on）" class="headerlink" title="some resources（博客资源 and so on）"></a>some resources（博客资源 and so on）</h1><p><span class="exturl" data-url="aHR0cHM6Ly9zcXVpZGFydGguY29tL3JjL3Byb2dyYW1taW5nL25ldHdvcmtpbmcvMjAxOC8wNy8xOC9pbnRyby1jb25nZXN0aW9uLmh0bWw=">squidarth:intro congestion-control<i class="fa fa-external-link-alt"></i></span></p>]]></content>
    
    <summary type="html">
    
      关于拥塞控制的常识/resources
    
    </summary>
    
    
      <category term="Summary" scheme="http://yoursite.com/categories/Summary/"/>
    
    
      <category term="Network" scheme="http://yoursite.com/tags/Network/"/>
    
  </entry>
  
  <entry>
    <title>建站 | Jekyll -》 mkdocs -》 hexo</title>
    <link href="http://yoursite.com/2020/07/30/siteBuilding/"/>
    <id>http://yoursite.com/2020/07/30/siteBuilding/</id>
    <published>2020-07-30T21:50:53.000Z</published>
    <updated>2020-08-08T15:22:56.574Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="Jekyll"><a href="#Jekyll" class="headerlink" title="Jekyll"></a>Jekyll</h1><p>之前是用的jekyll，但是没找到我想要的全局搜索功能，有兴趣的还是可以看下：<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hlc3lfSC9hcnRpY2xlL2RldGFpbHMvMTA0MTg0NzIw">Jekyll建站<i class="fa fa-external-link-alt"></i></span></p><hr><h1 id="mkdocs"><a href="#mkdocs" class="headerlink" title="mkdocs"></a>mkdocs</h1><blockquote><p>其实Jekyll已经省去了很多麻烦了，但是我真的真的很烦每个md开头要写一大段乱七八糟的配置，不方便迁移，所以就转到mkdocs了，虽然模板的页面效果没有Jekyll丰富，但是对懒人还是极其友好的。</p></blockquote><blockquote><p>本来想用mkdocs的，毕竟还是挺省事儿的，文件结构也很清晰，学神点拨下我发现hexo可以全局搜索，跟mkdocs的标题搜索等级比起来，更香了！<br>简单学了下，后续可能考虑用mkdocs做一些项目文档手册，作为子网址吧，做手册挺合适的。</p></blockquote><h2 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h2><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cueG5jb2RpbmcuY29tLzIwMjAvMDMvMDEvdG9vbC9ta2RvY3MuaHRtbA==">蛮详细的，尤其是关于yml配置文件相关的<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d1dG9uZ3RyZWUuZ2l0aHViLmlvL2Rldm9wcy9tYW5hZ2UteW91ci1jbXMtdXNpbmctbWtkb2Nz">配置也很详细，尤其有一些关于mkdocs的冷知识<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9teS5vc2NoaW5hLm5ldC9menhpYW9tYW5nZS9ibG9nLzMwMTA5MjE=">列了一些注意事项，which我也觉得很重要<i class="fa fa-external-link-alt"></i></span></li><li>这个没仔细看，但是感觉很高贵的样子 <span class="exturl" data-url="aHR0cHM6Ly90b3V0aWFvLmlvL3Bvc3RzL3Q5M2E1Yy9wcmV2aWV3">将 Jupyter 自动发布到 GitHub Pages<i class="fa fa-external-link-alt"></i></span></li></ul><h2 id="配置中遇到的问题"><a href="#配置中遇到的问题" class="headerlink" title="配置中遇到的问题"></a>配置中遇到的问题</h2><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0b25lOTE1OS9hcnRpY2xlL2RldGFpbHMvNzkwNzEzMTY=">py37下字符编码遇到的问题<i class="fa fa-external-link-alt"></i></span></p><hr><h1 id="hexo"><a href="#hexo" class="headerlink" title="hexo"></a>hexo</h1><blockquote><p>我的两个config.xml（_config.next.xml是对应next主题的配置）都做了比较详细的注释，大家改起来也会很方便，欢迎在我的基础上修改！（虽然我本来也就是改学神的 :)</p></blockquote><h2 id="ref-1"><a href="#ref-1" class="headerlink" title="ref"></a>ref</h2><ol><li><p>环境配置请参考：<span class="exturl" data-url="aHR0cHM6Ly9scnNjeS5naXRodWIuaW8vMjAxNy8xMS8xMC9VYnVudHUtR2l0aHViLWlvLWNvbmZpZy1IZXhvLw==">linux下使用hexo建站<i class="fa fa-external-link-alt"></i></span>    </p><blockquote><ul><li>安装的时候提示8.x已经deprecated，所以我按照提示安装了12.x</li><li>在服务器上跑<code>npm install -g hexo-cli</code>等命令的时候，会遇到权限不够，根据提示给sudo就行</li></ul></blockquote></li><li><p>推送过程和基本配置网上已经很多了</p><blockquote><ul><li>next主题的仓库已经过期，我用的是学神给的这个：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RoZW1lLW5leHQvaGV4by10aGVtZS1uZXh0">https://github.com/theme-next/hexo-theme-next<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly90ZGluZy50b3AvYXJjaGl2ZXMvNDJjMzhiMTAuaHRtbA==">next主题的基本设置<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC85NDAzODY4OA==">hexo主题进阶设置<i class="fa fa-external-link-alt"></i></span></li></ul></blockquote></li><li><p>其他trivial的可选功能</p><blockquote><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC9kNjhkZTA2N2VhNzQ=">Hexo添加Disqus评论<i class="fa fa-external-link-alt"></i></span></li><li>hexo添加google-analytic功能 （ 不想做了2333累了</li></ul></blockquote></li></ol><h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><p>hexo new ‘文章标题’<br>hexo new draft<br> hexo clean</p><blockquote><p>清除缓存文件 (db.json) 和已生成的静态文件 (public)。在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。</p></blockquote><p>hexo g<br>hexo s<br>hexo d</p><hr><h1 id="mkdown-图床-获取-永久链接-（-香"><a href="#mkdown-图床-获取-永久链接-（-香" class="headerlink" title="mkdown+图床 获取 永久链接 （ 香"></a>mkdown+图床 获取 永久链接 （ 香</h1><p>可以参考<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hlc3lfSC9hcnRpY2xlL2RldGFpbHMvMTA3NjIyMjAy">我之前写的文章：typora+gitee图床<i class="fa fa-external-link-alt"></i></span></p><hr><h1 id="Actions"><a href="#Actions" class="headerlink" title="Actions"></a>Actions</h1><ul><li><input checked="" disabled="" type="checkbox"> <span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81YzQxN2RhNzUxODgyNTI1YzYzODA5Y2Q=">简单入个门<i class="fa fa-external-link-alt"></i></span></li><li><input checked="" disabled="" type="checkbox"> <span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC82ODU0NTczMjE4Nzc5MzgxNzcz">hexo+Actions保姆教程<i class="fa fa-external-link-alt"></i></span></li></ul><p>本来想自己写的，结果学神也用的actions，哈哈作业一抄到底 （ docker确实不太精通啊…  - -||| ）</p><hr><h1 id="miscelleous"><a href="#miscelleous" class="headerlink" title="miscelleous"></a>miscelleous</h1><ul><li><input disabled="" type="checkbox"> 添加多个部署源<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">deploy</span>:</span><br><span class="line">- <span class="attribute">type</span>: git</span><br><span class="line">  <span class="attribute">repo</span>:</span><br><span class="line">- <span class="attribute">type</span>: heroku</span><br><span class="line">  <span class="attribute">repo</span>:</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      github pages建站
    
    </summary>
    
    
      <category term="程序员的自我修养" scheme="http://yoursite.com/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"/>
    
    
      <category term="tool" scheme="http://yoursite.com/tags/tool/"/>
    
  </entry>
  
</feed>
