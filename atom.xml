<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hesy&#39;s Blog</title>
  
  <subtitle>Seek for your love</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-10-21T19:24:32.693Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Hesy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>rlDemo</title>
    <link href="http://yoursite.com/2020/10/22/rlDemo/"/>
    <id>http://yoursite.com/2020/10/22/rlDemo/</id>
    <published>2020-10-22T01:54:51.000Z</published>
    <updated>2020-10-21T19:24:32.693Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="Q-learning"><a href="#Q-learning" class="headerlink" title="Q-learning"></a>Q-learning</h1><p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2RhdGF3aGFsZWNoaW5hL2xlZWRlZXBybC1ub3Rlcy9ibG9iL21hc3Rlci9jb2Rlcy9RLWxlYXJuaW5nL21haW4ucHk=">base代码<i class="fa fa-external-link-alt"></i></span></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 老是说我没有权限就很烦...</span></span><br><span class="line">sudo /home/hesy/.conda/envs/py36/bin/python main.py <span class="comment"># use default config  0.9,0.9,0.1,200,0.1,500</span></span><br><span class="line">sudo /home/hesy/.conda/envs/py36/bin/python main.py --gamma 0.95 --me 100</span><br><span class="line">sudo /home/hesy/.conda/envs/py36/bin/python main.py --gamma 0.95 --es 0.99 --me 100</span><br></pre></td></tr></table></figure><ul><li><p>ε-decay和ε-start还有ε-end是耦合的，第一个感觉比较难调整，就调后面两个好了<img   src="C:\Users\hesy\AppData\Roaming\Typora\typora-user-images\image-20201022023149453.png" alt="image-20201022023149453" style="zoom: 50%;" /></p><ul><li><p>先用默认参数跑了下，发现其实100步已经妥妥收敛了（右边），所以<strong>me果断设置100</strong> ，确实还不错（见下）</p><p><img src="https://gitee.com/HesyH/Image-Hosting/raw/master/image4typora/202010/22/030751-545506.png" alt="image-20201022030700622" style="zoom: 67%;" /><img src="https://gitee.com/HesyH/Image-Hosting/raw/master/image4typora/202010/22/031416-949404.png" alt="image-20201022030741939" style="zoom:67%;" /></p></li><li><p>最短路径是15步，所以<strong>gamma</strong>我取了个1-1/15，<strong>约等于0.95</strong></p><p><img src="https://gitee.com/HesyH/Image-Hosting/raw/master/image4typora/202010/22/025053-715031.png" alt="image-20201022025051942" style="zoom: 67%;" /><img src="https://gitee.com/HesyH/Image-Hosting/raw/master/image4typora/202010/22/031206-822872.png" alt="image-20201022024836105" style="zoom:50%;" /></p><p>目前看效果还不错（如上），肯定是train好了，接着调</p></li><li><p><strong>ee 调到0.99</strong>，希望一开始探索多一点</p><p><img src="https://gitee.com/HesyH/Image-Hosting/raw/master/image4typora/202010/22/031126-830561.png" alt="image-20201022025738159" style="zoom:67%;" /><img src="https://gitee.com/HesyH/Image-Hosting/raw/master/image4typora/202010/22/031206-89443.png" alt="image-20201022025802328" style="zoom:67%;" /></p><blockquote><p>可以看到一开始探索多了以后，学习得居然也快了,说明探索到了好的方法</p></blockquote></li><li><p>再分别试试<strong>调大学习率</strong>（0.15）和<strong>调小学习率（0.05</strong>）</p><p><img src="https://gitee.com/HesyH/Image-Hosting/raw/master/image4typora/202010/22/030056-455700.png" alt="image-20201022030055460" style="zoom:67%;" /><img src="https://gitee.com/HesyH/Image-Hosting/raw/master/image4typora/202010/22/030335-443486.png" alt="image-20201022030055460" style="zoom:67%;" /></p><blockquote><p>学习率大了以后果然学的就是快hhh </p></blockquote></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      toy play of rl
    
    </summary>
    
    
      <category term="Summary" scheme="http://yoursite.com/categories/Summary/"/>
    
    
      <category term="Reinforcement Learning" scheme="http://yoursite.com/tags/Reinforcement-Learning/"/>
    
  </entry>
  
  <entry>
    <title>rlReview</title>
    <link href="http://yoursite.com/2020/10/20/rlReview/"/>
    <id>http://yoursite.com/2020/10/20/rlReview/</id>
    <published>2020-10-20T01:28:19.000Z</published>
    <updated>2020-10-21T19:24:32.693Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="回顾的时候-一下子没想出来的问题"><a href="#回顾的时候-一下子没想出来的问题" class="headerlink" title="回顾的时候 一下子没想出来的问题"></a>回顾的时候 一下子没想出来的问题</h1><ul><li><p>强化学习相对于监督学习为什么训练会更加困难？（强化学习的特征）</p><ul><li><p>强化学习处理的多是序列数据，其很难像监督学习的样本一样满足IID（独立同分布）条件。( needs trivial handling )</p></li><li><p>强化学习有奖励的延迟（Delay Reward），即在Agent的action作用在Environment中时，Environment对于Agent的State的奖励的延迟（Delayed Reward），使得反馈不及时。</p></li><li><p>相比于监督学习有正确的label，可以通过其修正自己的预测，强化学习相当于一个“试错”的过程，其完全根据Environment的“反馈”更新对自己最有利的Action。</p></li></ul></li><li><p>为什么在马尔可夫奖励过程（MRP）中需要有<strong>discount factor</strong>?</p><ul><li><p>有些马尔可夫过程是<strong>带环</strong>的，它并没有终结，然后我们想<strong>避免这个无穷的奖励</strong>；</p></li><li><p>当前步对遥远未来的reward的<strong>贡献</strong>比较小，所以用discount factor弱化未来的奖励在当前步骤的累加值；</p></li><li><p>考虑奖励的<strong>不确定性</strong>：假设在从当前步采取同样的action开始，采样不同的trace，可能有的会会有最终奖励、有的不会（这里以打游戏为例，通关得到的最终奖励远大于平时每个步骤得到的微小奖励 ( 有的设置里面平时的奖励实际上都没有，就只设置最终步骤的奖励 ) ）。综上，未来的奖励是受后续trace影响的，也就是不确定的，有一定概率的，所以从这个角度来看，我们也要给这个未来奖励打一个折扣。</p><blockquote><p>考虑不打折扣的情况–》γ都是1的情况下，就很糟糕。</p></blockquote></li></ul></li><li><p>为什么说Sarsa ( on-policy ) 更加保守，而Q-learning ( off-policy ) 更加大胆（鼓励探索）呢？</p><p><img src="https://images.weserv.nl/?url=https://datawhalechina.github.io/leedeeprl-notes/chapter3/img/3.18.png" alt="img"></p><p>可以看到，虽然都是使用ε-greedy算法选择动作，但是对于同一个动作( especially探索出来的动作 )，Q-learning给分会比较高（毕竟是给了一个argmax的action对应的值哇）。那么一旦给分高了以后，偏向选择这个动作的概率就会大，就会探索出更多以这个action开头的trace，其中说不定能找到一个比之前更好的trace。而如果是Sarsa的话，这一次探索之后该动作对应的Q值一跃成为最大值可能性就小很多了。与之相比，Q-learning其实就是鼓励探索的。</p><blockquote><p><code>&quot;那么一旦给分高了以后，偏向选择这个动作的概率就会大&quot;</code></p><p> 这里要区分一个概念：对于ε-greedy来说，除了使得值函数的值最大的那个action以外，其他所有的action的选取概率实际上都是一样的。如果想要按照值函数大小为概率来选择动作的话，可以考虑玻尔兹曼策略或者UCB策略。</p><p>所以，这句话的隐含意思是，<strong>很大可能</strong>这次更新后( 因为加上的是最大值啊喂 )，这个动作对应的Q-value就一跃成为最大值（之一）了，此时其被选取、探索的概率就会变大。</p></blockquote><blockquote><p><strong>个人认为</strong>，Q-learning这方法会跟UCB做赌博机的那个实验效果一样，倾向于<strong>把所有的动作空间都try一遍</strong>（因为一旦概率落到新动作上，如果学习率比较大，那么这个新动作的Q值一下子就会变得很大，一跃成为Q值最大的，所以下次会优先(大概率)选择它，然后就相当于展开了以它为根结点的探索空间）……</p><p>支撑论据：</p><blockquote><p>refer@<span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzI2ODQ2MTg2Ng==">知乎<i class="fa fa-external-link-alt"></i></span>，which第一个高票回复我觉得不对，直接在评论里面怼回去了。</p><img src="C:\Users\hesy\AppData\Roaming\Typora\typora-user-images\image-20201021175117502.png" alt="image-20201021175117502" style="zoom: 80%;" /><ul><li><p>可以看到同样的情况下，Q-learning收敛比较慢（因为探索的概率更大哇），但是一旦收敛，就比较稳定了。但是Sarsa就不一样，收敛了以后，由于探索性探索到的动作之前没有好好学习到，所以经常会出现锯齿（which Q-learning已经在前期探索到比较好的策略了）[所以<span class="exturl" data-url="aHR0cHM6Ly9kYXRhd2hhbGVjaGluYS5naXRodWIuaW8vbGVlZGVlcHJsLW5vdGVzLyMvY2hhcHRlcjMvY2hhcHRlcjM=">有人<i class="fa fa-external-link-alt"></i></span>说的“sarsa因为要兼顾探索所以策略不稳定“是这个意思( 并不是说q-learning就没有兼顾探索了hh) ]</p></li><li><p>另一方面，Sarsa由于缺乏探索性（偏向保守），所以没有收敛到一个最优解，也许需要更长的时间才能收敛到Q-learning的程度 ( 可以看到收敛曲线其实还是在缓慢下降的 )</p></li></ul></blockquote><p>所以动作空间别太大哈，不然不就凉凉了2333 【个人觉得off-policy 学习率大的时候适合动作空间比较小的】</p><blockquote><p>which事实证明并不是的2333….我着实没想通</p></blockquote></blockquote><blockquote><p><strong>异策略可以保证充分的探索性</strong>。例如⽤来评估和改善的策略是贪婪策略，⽤于产⽣数据的探索性策略为探索性策略，如ε-soft策略。  – 郭宪 《深入浅出强化学习：原理入门》</p></blockquote></li></ul><ul><li><p>ε-greedy策略是是ε-soft策略中的一种</p><p>如果“严格”的说，ε-greedy策略是$\frac{ϵ}{A(s)}-soft$的策略。</p><p>解释请参考<span class="exturl" data-url="aHR0cDovL2ZhbmN5ZXJpaS5naXRodWIuaW8vYm9va3MvcmwzLw==">这个博客<i class="fa fa-external-link-alt"></i></span></p></li><li><p>值迭代和策略迭代</p><p>其实MC和TD都是基于值迭代的范式（见《编程实践》书P64），所以SARSA和Q-learning也都是值迭代引出来的，只不过一个是同策略，另一个是异策略（Levine说过PG反而有点像策略爹地啊</p></li></ul><h1 id="question"><a href="#question" class="headerlink" title="question"></a>question</h1><ul><li><p><input disabled="" type="checkbox">  【强化学习】中Q-learning,DQN等off-policy算法不需要重要性采样的原因</p><ul><li><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNzg5NTMzOS9hcnRpY2xlL2RldGFpbHMvODQ4ODExNjk=">CSDN<i class="fa fa-external-link-alt"></i></span></p></li><li><p>同策略 采样大，收敛慢； Q-learning 是异策略，还不需要importance sampling </p><blockquote><p>但是我看Q-learning也是一步一更新哇…感觉采样大这个劣势并没有利用好？</p></blockquote></li></ul></li><li><p><input disabled="" type="checkbox">  编程实战书P21 要结合历史观测 是因为部分可观测性？而不是因为非马尔可夫性？</p><p>似乎说得通… 我是因为没有认清当前的状态是什么所以才需要多个state拼在一起的窗口</p></li></ul>]]></content>
    
    <summary type="html">
    
      Summary
    
    </summary>
    
    
    
      <category term="Reinforcement Learning" scheme="http://yoursite.com/tags/Reinforcement-Learning/"/>
    
  </entry>
  
  <entry>
    <title>DRL-TE</title>
    <link href="http://yoursite.com/2020/10/19/PaperReading/DRL-TE/"/>
    <id>http://yoursite.com/2020/10/19/PaperReading/DRL-TE/</id>
    <published>2020-10-19T10:25:51.000Z</published>
    <updated>2020-10-21T19:24:32.693Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="hesy-summary"><a href="#hesy-summary" class="headerlink" title="hesy summary"></a>hesy summary</h1><ul><li>排队论不适合多跳排队问题的建模<ul><li>强假设不能满足</li><li>多跳排队还是个open problem</li></ul></li></ul><h1 id="abstract"><a href="#abstract" class="headerlink" title="abstract"></a>abstract</h1><p>​    现代通信网络已经变得非常复杂且高度动态，这使其难以建模，预测和控制。 在本文中，我们开发了一种新颖的体验驱动方法，可以像人类学习新技能（例如驾驶，游泳等）一样，根据自身的经验而不是准确的数学模型来学习很好地控制通信网络。 具体来说，我们首次建议利用新兴的深度强化学习（DRL）在通信网络中实现无模型控制； 并针对基础网络问题：流量工程（TE），提出了一种新颖且高效的基于DRL的控制框架DRL-TE。通过共同学习网络环境及其动态性，并在强大的深度神经网络（DNN）的指导下进行决策，<strong>所提出的框架最大程度地提高了广泛使用的效用函数</strong>。<strong>我们提出了两种新技术</strong>，即TE感知探索和基于行为者批评的优先体验重播，以优化通用DRL框架，尤其是针对TE的框架。 为了验证和评估所提出的框架，我们在<strong>ns-3</strong>中实施了该框架，<strong>并使用代表性和随机生成的网络拓扑进行了全面测试</strong>。 广泛的数据包级仿真结果表明：1）与几种广泛使用的基准方法相比，DRL-TE显着<u>降低了端到端延迟</u>，并不断提高了网络实用性，<u>同时提供了更好或相当的吞吐量</u>；  2）DRL-TE对网络的变化更具有鲁棒性； 和3）DRL-TE始终优于最新的DRL方法（用于连续控制），即深度确定性策略梯度（DDPG），但是它不能提供令人满意的性能。</p><h1 id="introduction"><a href="#introduction" class="headerlink" title="introduction"></a>introduction</h1><p>​    已经进行了广泛的研究努力来开发用于通信网络的算法和协议，以有效地利用它们的资源。 传统的网络资源分配方法大多是基于模型的，它们假定可以很好地建模网络环境和用户需求。 然而，通信网络变得更加复杂且高度动态，这使其难以建模，预测和控制。 因此，我们的目标是开发一种新颖的，无需经验的无模型方法，该方法可以像人类学习技能（例如驾驶，游泳等）一样，从经验中学习很好地控制通信网络，而不是精确的数学模型。我们认为，某些新兴的联网技术，例如软件定义网络（SDN）[18]，可以很好地支持这种体验/数据驱动的方法。 例如，SDN中的<strong>Openflow</strong>控制器可以用作中央控制单元，用于收集数据，制定决策和部署解决方案。</p><p>​    一个基本的网络问题是流量工程（TE）：给定一组具有源节点和目标节点的网络流，请找到一种解决方案，以最大化实用功能为目标转发数据流量。 简单且广泛使用的解决方案包括：始终通过最短路径路由流量（例如，开放式最短路径优先（OSPF）[24]）； 或通过多个可用路径平均分配流量（例如，有效负载平衡<strong>（VLB）[38]**）。 显然，它们都不是最优的。 如果存在针对网络环境，用户需求及其动态的准确且数学可解的模型，则可以开发出更好的解决方案。 <u>排队论已被用于对通信网络进行建模并协助资源分配[15]，[25]，[26]，[37]</u>。 **但是，由于以下原因，它可能不适用于涉及多跳路由和端到端性能（例如延迟）的网络问题</strong>：1）在排队论中，queueing network（而不是单个队列）中的许多问题仍然是开放问题，而具有网状拓扑结构的通信网络则表示相当复杂的多点到多点排队网络，其中来自一个队列可以被分布到多个下游队列，并且一个队列可以从多个不同的上游队列接收分组。  2）<u>排队理论只能在一些强假设下（例如，元组到达遵循泊松分布等）提供准确的排队延迟估计，但是在复杂的通信网络中可能不成立</u>。 请注意，即使到达每个源节点的数据包都遵循泊松分布，到达中间节点的数据包也可能不会。</p><h1 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h1><h3 id="abstract-1"><a href="#abstract-1" class="headerlink" title="abstract"></a>abstract</h3><ul><li>ns3的话 拓扑规模？</li><li>DRL-TE怎么和DDPG对比起来了，不是两种不同的东西么…</li><li>VLB和ECMP的区别</li></ul><ul><li>我们一定要做分布式的么？不做的话会怎么样–》无法达到全局最优 ?  Auto怎么被评论的？</li><li>有哪些open review的会议</li><li>Caida数据集</li><li>ospf最短路径的权重问题？</li></ul>]]></content>
    
    <summary type="html">
    
      Infocom&#39;18
    
    </summary>
    
    
      <category term="PaperReading" scheme="http://yoursite.com/categories/PaperReading/"/>
    
    
      <category term="Network" scheme="http://yoursite.com/tags/Network/"/>
    
      <category term="Reinforcement Learning" scheme="http://yoursite.com/tags/Reinforcement-Learning/"/>
    
      <category term="Routing" scheme="http://yoursite.com/tags/Routing/"/>
    
  </entry>
  
  <entry>
    <title>SQR&amp;DLWR|Evaluating and Boosting Reinforcement Learning for Intra-domain Routing</title>
    <link href="http://yoursite.com/2020/10/19/PaperReading/SQR-DLWR/"/>
    <id>http://yoursite.com/2020/10/19/PaperReading/SQR-DLWR/</id>
    <published>2020-10-19T10:24:31.000Z</published>
    <updated>2020-10-21T19:24:32.693Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="abstract"><a href="#abstract" class="headerlink" title="abstract"></a>abstract</h1><p>机器学习在计算机视觉和计算机游戏等领域的成功引发了人们对在计算机网络中应用机器学习的兴趣激增。 本文试图回答一个广泛争论的问题：我们能否通过强化学习（RL）来提高域内路由的性能，域内路由是Internet上最基本的模块之一？ 由于复杂的网络流量条件和较大的路由选择空间，很难为现有的基于RL的路由解决方案给出确切的答案。 为了深入了解基于RL的路由的挑战，我们系统地对不同的基于RL的路由解决方案进行了分类，并从可扩展性，稳定性，鲁棒性和收敛性方面研究了几种代表性方法的性能。 结合评估各种基于RL的路由解决方案的经验教训，我们提出了两种方法，称为监督Q网络路由（supervised Q-network routing (SQR)）和基于离散链路权重的路由（discrete link weight-based routing，DLWR），它们可以提高基于RL的路由的性能，并提高性能。 形成事实上的最短路径域内路由。</p><h1 id="introduction"><a href="#introduction" class="headerlink" title="introduction"></a>introduction</h1><p>​    路由是一种网络功能，可将数据包从给定的源传递到给定的目的地。 可以说，它是Internet中最基本的构建块，在服务质量（QoS）保证中起着至关重要的作用。 传统的路由策略，例如开放式最短路径优先（OSPF）路由[1]，可能会导致网络拥塞和链路利用率低，并且与<strong>最佳路由方法相比，性能可能会差5000倍[2]**。 在动态业务量变化的情况下，已经致力于优化路由路径。 例如，反压路由[3]最初是为无线网络提出的，也可以应用在有线网络中，它基于相邻节点之间的拥塞梯度来动态转发流量。 但是，它在路由路径中的收敛速度可能会很长，</strong>并且不一定会导致良好的小队列性能，如[4]<strong>中所证明的。 将机器学习应用于网络路由以获得更好的性能可以追溯到1994年，</strong>当时提出了Q路由的概念[5]。** 由于机器学习在其他领域（例如计算机视觉，游戏和自然语言处理）的巨大成功，最近对Q路由的兴趣再<strong>次兴起[6] [7]**。 另外，最近的一些研究通过在路由中应用深度（强化）学习，证明了令人鼓舞的结</strong>果[8] – [10]<strong>。 这些研究讨论了潜在的基于学习的路由方法，并使用一些典型的机器学习方法进行了评估，例如深度信念架构，深度神经网络（DNN）和信任区域策略优化（TRPO）。 **但是，Internet路由的性能在很大程度上取决于流量动态和各种网络状况</strong>。 <strong>例如，现有的Q路由及其变体会在数据包级别更新路由表，即，他们了解环境并估算单个数据包的数据包交付时间</strong>。 显然，它们的性能在高速网络中会受到影响，在高速网络中，数据包需要以微秒为单位转发。 <strong>在所有路由方案中，一个解决方案都不可能成为“最佳”解决方案并胜过其他解决方案</strong>。 根据这一观察，我们因此有动机去研究Internet路由中不同机器学习算法的利弊，并清除一些（虽然不太可能是全部）在路由中实际采用机器学习的障碍。 我们的研究并非不切实际地针对设计最有效的路由解决方案。 相反，我们提供了lessons(这里我觉得翻译成经验比较好)，在此基础上，我们展示了如何进一步改进现有方法。 </p><p>​    为此，我们研究了基于不同强化学习（RL）的路由策略对域内Internet路由性能的影响。 由于以下三个原因，我们缩小了关注点到RL和域内路由的: (1)<strong>基于RL的路由[8]不需要标记的数据</strong>，由于操作数据的规模大和网络的规模大，这是禁止的并且难以获得 状态;  （2）在路由器处于同一自治系统（AS）域内的域内路由中，可以获得所有路由信息；  （3）软件定义网络（SDN）的发展使通过全局网络视图通过中央控制平面实现智能路由算法变得容易了[11]。</p><p>​    我们在以下方面评估基于RL的路由：(1) <strong>可扩展性</strong>：在高速，大规模网络中是否可以保持良好的性能？(2) <strong>稳定性</strong>：路由方法是否对各种流量模式和网络条件具有弹性？(3) <strong>健壮性</strong>：路由方法是否可以有效避免“不良”路由状态?（例如，congested,long-delay links）？(4) <strong>Convergence</strong>：是否可以快速达到新的路由策略以适应动态网络变化？ 我们对强化学习的研究基于两种主要方法，即基于价值的优化方法和基于策略的优化方法。 图1总结了每种方法的架构及其相应的算法。在我们的研究中，对图1中标有*的算法（它们是强化学习的代表算法）进行了评估。 本文的贡献可以总结如下：</p><h1 id="疑问"><a href="#疑问" class="headerlink" title="疑问"></a>疑问</h1><ul><li><p>introduction中说到Q路由的事情</p><ul><li><p>在数据包级别更新路由表 ，能保证收敛么…</p></li><li><p>需要调研这些文章</p></li><li><p><strong>在所有路由方案中，一个解决方案都不可能成为“最佳”解决方案并胜过其他解决方案</strong></p><blockquote><p>原来路由也是分场景的！</p></blockquote></li></ul></li><li></li></ul>]]></content>
    
    <summary type="html">
    
      MASS&#39;19
    
    </summary>
    
    
      <category term="PaperReading" scheme="http://yoursite.com/categories/PaperReading/"/>
    
    
      <category term="Network" scheme="http://yoursite.com/tags/Network/"/>
    
      <category term="Reinforcement Learning" scheme="http://yoursite.com/tags/Reinforcement-Learning/"/>
    
      <category term="Routing" scheme="http://yoursite.com/tags/Routing/"/>
    
  </entry>
  
  <entry>
    <title>pythonConfig</title>
    <link href="http://yoursite.com/2020/09/28/pythonConfig/"/>
    <id>http://yoursite.com/2020/09/28/pythonConfig/</id>
    <published>2020-09-28T01:34:53.000Z</published>
    <updated>2020-10-21T19:24:32.693Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="查看whl文件需要满足的条件"><a href="#查看whl文件需要满足的条件" class="headerlink" title="查看whl文件需要满足的条件"></a>查看whl文件需要满足的条件</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> wheel.pep425tags</span><br><span class="line">print(wheel.pep425tags.get_supported())</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      python配置相关总结
    
    </summary>
    
    
      <category term="Codes" scheme="http://yoursite.com/categories/Codes/"/>
    
    
      <category term="Language" scheme="http://yoursite.com/tags/Language/"/>
    
  </entry>
  
  <entry>
    <title>UDT</title>
    <link href="http://yoursite.com/2020/09/22/Codes/UDT/"/>
    <id>http://yoursite.com/2020/09/22/Codes/UDT/</id>
    <published>2020-09-22T22:35:59.000Z</published>
    <updated>2020-10-21T19:24:32.693Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="收集的、待整理的文章"><a href="#收集的、待整理的文章" class="headerlink" title="收集的、待整理的文章"></a>收集的、待整理的文章</h1><p>先不看架构了，直接看Aurora了</p><ul><li>wolfcs大佬的博客优先看，在reference那一节里面说了</li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vdWtlcm5lbC9wLzg5NzY5ODQuaHRtbA==">https://www.cnblogs.com/ukernel/p/8976984.html<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuc2xpZGVzdGFsay5jb20vdTQyL3Q4ZWZqaw==">https://www.slidestalk.com/u42/t8efjk<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2t0bGlmZW5nL2FydGljbGUvZGV0YWlscy83ODUzMzM1NQ==">https://blog.csdn.net/ktlifeng/article/details/78533355<i class="fa fa-external-link-alt"></i></span></li></ul><h1 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h1><ul><li><p><span class="exturl" data-url="aHR0cHM6Ly91ZHQuc291cmNlZm9yZ2UuaW8v">sourceforge官网<i class="fa fa-external-link-alt"></i></span> 【05年出的，更新到09年】</p><blockquote><p>ppt 、poster、documention、discussion/help 版块(including Chinese)</p></blockquote></li><li><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2FzZGZnaGprbDE5OTMvYXJ0aWNsZS9kZXRhaWxzLzU3NDE3MDc0">udt初步介绍<i class="fa fa-external-link-alt"></i></span> 里面有UDT的架构图，可惜没有再出后续了…</p><blockquote><img src="https://img-blog.csdn.net/20170226170700588?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYXNkZmdoamtsMTk5Mw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img" style="zoom: 33%;" /><img src="https://img-blog.csdn.net/20170226170750116?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYXNkZmdoamtsMTk5Mw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="img" style="zoom:33%;" /></blockquote></li><li><p><input checked="" disabled="" type="checkbox">  大佬系列博客：<span class="exturl" data-url="aHR0cHM6Ly93d3cud29sZmNzdGVjaC5jb20vY2F0ZWdvcmllcy8lRTclQkQlOTElRTclQkIlOUMlRTUlOEQlOEYlRTglQUUlQUUvcGFnZS81Lw==">udt源码分析<i class="fa fa-external-link-alt"></i></span> 后续想要读源码的话可以==再仔细看一下==（目前只是大概浏览了下）,which我觉得讲得真的不错</p><ul><li><p><input disabled="" type="checkbox">  大佬还有系列在<span class="exturl" data-url="aHR0cHM6Ly9teS5vc2NoaW5hLm5ldC93b2xmY3M=">oschina的平台上<i class="fa fa-external-link-alt"></i></span></p><blockquote><ul><li><input disabled="" type="checkbox"> 发送窗口大小及发送速率的调整</li><li><input checked="" disabled="" type="checkbox"> 实现分析总结</li></ul></blockquote></li></ul><blockquote><ul><li><p>UDT::startup()的调用过程为：UDT::startup()-&gt; CUDT::startup() -&gt; CUDTUnited::startup()。</p><p>从这里也可以看出UDT、CUDT、CUDTUnited之间的关系</p></li><li><p>UDT的命名规则有些讲究，前缀代表着数据类型</p></li><li><p><strong>设计架构</strong></p><ul><li><p>socket创建那一章说的：UDT的使用者在调用UDT API时，UDT API会直接调用CUDT类对应的static API函数，在CUDT类的这些static API函数中会将做实际事情的工作委托给s_UDTUnited的相应函数，但这个委托调用会被包在一个try-catch block中。s_UDTUnited的函数在遇到异常情况时抛出异常，CUDT类的static API函数捕获异常，根据捕获到的异常的具体类型，创建不同的CUDTException对象设置给s_UDTUnited的线程局部存储变量m_TLSError中并向UDT API调用者返回错误码，UDT API的调用者检测到错误码后，通过UDT::getlasterror()获取存储在m_TLSError中的异常。</p></li><li><p>bind( )函数<span class="exturl" data-url="aHR0cHM6Ly93d3cud29sZmNzdGVjaC5jb20vMjAxNS8wOS8wOS9VRFQlRTUlOEQlOEYlRTglQUUlQUUlRTUlQUUlOUUlRTclOEUlQjAlRTUlODglODYlRTYlOUUlOTAlRTIlODAlOTQlRTIlODAlOTRiaW5kJUUzJTgwJTgxbGlzdGVuJUU0JUI4JThFYWNjZXB0Lw==">那一章<i class="fa fa-external-link-alt"></i></span>说的: 和socket创建时一样是==分为3层==：UDT命名空间中提供了给应用程序调用的接口，可称为<strong>UDT API或User API</strong>；User API调用CUDT API，这一层主要用来做错误处理，也就是捕获动作实际执行过程中抛出的异常并保存起来，然后给应用程序使用；CUDT API调用CUDTUnited中API的实现。</p><blockquote><p>“此处可以看到，CUDT提供的这一层API，一个比较重要的作用大概就是做异常处理了。”</p><p>其实这里没有很懂UDT的==设计艺术==，为什么要分三个层次的类，中间那个特别像个中间件，为什么异常处理要单独拎出来。</p></blockquote></li><li><p>bind( )函数<span class="exturl" data-url="aHR0cHM6Ly93d3cud29sZmNzdGVjaC5jb20vMjAxNS8wOS8wOS9VRFQlRTUlOEQlOEYlRTglQUUlQUUlRTUlQUUlOUUlRTclOEUlQjAlRTUlODglODYlRTYlOUUlOTAlRTIlODAlOTQlRTIlODAlOTRiaW5kJUUzJTgwJTgxbGlzdGVuJUU0JUI4JThFYWNjZXB0Lw==">那一章<i class="fa fa-external-link-alt"></i></span>还介绍了UDT的多路复用器CMultiplexer、通道CChannel、发送队列CSndQueue和接收队列CRcvQueue的含义</p><ul><li><p><strong>CChannel</strong></p><blockquote><p>系统UDP socket的一个封装，它主要封装了系统UDP socket handle，IP版本号，socket地址的长度，发送缓冲区的大小及接收缓冲区的大小等信息，并提供了用于操作 系统UDP socket进行数据收发或属性设置等动作的函数。</p></blockquote></li><li><p><input disabled="" type="checkbox">  其实没有很懂多路复用器(Multiplexer)和socket之间的关系 ( 监听端口到底是什么操作？我理解的目前是socketchannel可以实现在一个线程里面监听多个某个端口的状况 ( 是否接收了数据等等 ) 并将更新的情况跟selector ( 也就是多路复用器 ) 交流 ,which会选择让哪个socket去处理这件事情) 、</p></li><li><p>CRcvQueue</p><blockquote><p>在接收队列CRcvQueue的worker线程中，接收到一条消息之后，它会根据消息的目标SocketID，及发送端的地址等信息，将消息以不同的方式进行dispatch</p></blockquote></li></ul></li></ul></li></ul></blockquote></li><li><p><input disabled="" type="checkbox">  这个<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vdWtlcm5lbC9wLzg5NzY5ODQuaHRtbA==">UDT源码剖析<i class="fa fa-external-link-alt"></i></span>系列博客讲得很详细，相当于每个头文件在讲解了</p></li><li><p><span class="exturl" data-url="aHR0cDovL3d3dy53aXNlc3R1ZHkuY24vb3BlbnRlY2gvdWR0LWNvbmdlc3Rpb25Db250cm9sQWxnb3JpdGhtLmh0bWw=">这个博客<i class="fa fa-external-link-alt"></i></span>相当于翻译了udt的论文</p></li><li><p><input disabled="" type="checkbox">  ==CS 224==的那个project是怎么整的 还得看下</p></li><li><p>udt思路及代码分析</p><ul><li><input disabled="" type="checkbox"> <span class="exturl" data-url="aHR0cDovL3d3dy53aXNlc3R1ZHkuY24vb3BlbnRlY2gvdWR0LWNvbmdlc3Rpb25Db250cm9sQWxnb3JpdGhtLmh0bWw=">这个<i class="fa fa-external-link-alt"></i></span>里面有代码架构分析</li><li><input disabled="" type="checkbox"> <span class="exturl" data-url="aHR0cHM6Ly9uZXR3b3JrLjUxY3RvLmNvbS9hcnQvMjAxNDA5LzQ1MTEzOS5odG0=">这个<i class="fa fa-external-link-alt"></i></span>里面有伪代码</li></ul></li><li><p><span class="exturl" data-url="aHR0cHM6Ly91ZHQuc291cmNlZm9yZ2UuaW8vdWR0NC8=">官方提供的reference<i class="fa fa-external-link-alt"></i></span>里面就有api手册  [代码的doc文件里面也可以离线查看]</p></li></ul><h1 id="代码架构"><a href="#代码架构" class="headerlink" title="代码架构"></a>代码架构</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">./src:     UDT <span class="built_in">source</span> code </span><br><span class="line">./app:     Example programs </span><br><span class="line">./doc:     UDT documentation (HTML)</span><br><span class="line">./win:     Visual C++ project files <span class="keyword">for</span> the Windows version of UDT </span><br></pre></td></tr></table></figure><h2 id="整体结构"><a href="#整体结构" class="headerlink" title="整体结构"></a>整体结构</h2><p>refer@WolfCS的<span class="exturl" data-url="aHR0cHM6Ly9teS5vc2NoaW5hLm5ldC93b2xmY3MvYmxvZy81MTIwNjE=">UDT实现分析总结<i class="fa fa-external-link-alt"></i></span></p><ul><li><p><strong>UDT Socket</strong>是UDT中的核心，同时它也是一座桥梁，它将UDT的使用者应用程序与内部实现部分对于数据结构的管理、网络数据的传输连接起来。</p></li><li><p><strong>应用程序通过它</strong>将数据放进发送缓冲待发送，或者借由它来获取从网络接收数据。而与网络进行交互的部分，则从它那里拿到要发送的数据进行发送，或者在收到packet时将packet dispatch给它。</p></li></ul><h3 id="数据接收部分框架"><a href="#数据接收部分框架" class="headerlink" title="数据接收部分框架"></a>数据接收部分框架</h3><img src="http://static.oschina.net/uploads/space/2015/0928/110552_YTa3_919237.jpg" alt="110552_YTa3_919237.jpg" style="zoom: 67%;" /><h3 id="数据发送部分框架"><a href="#数据发送部分框架" class="headerlink" title="数据发送部分框架"></a>数据发送部分框架</h3><img src="http://static.oschina.net/uploads/space/2015/0928/135751_Ftye_919237.jpg" alt="img" style="zoom:67%;" /><h2 id="UDT-socket-structures"><a href="#UDT-socket-structures" class="headerlink" title="UDT socket structures"></a>UDT socket structures</h2><img src="https://gitee.com/HesyH/Image-Hosting/raw/master/image4typora/202009/25/141253-492288.png" alt="image-20200923200351000" style="zoom: 80%;" /><ul><li><p>socket文件描述符 +  错误码 + UDT socket集合 + TraceInfo ()</p><ul><li><p>TraceInfo , performance的一些数据</p><ul><li><p><strong>aggregate</strong> values</p><ul><li>pktSndLossTotal 和 pktRcvLossTotal的区别？？这个RcvLoss怎么测试呢==？？==</li></ul></li><li><p><strong>local</strong> values since last recorded time</p><blockquote><p>目前理解是一段时间的period算出来的值  ==??不是很确定==</p></blockquote></li><li><p><strong>instant</strong> values at the time they are observed</p></li></ul></li></ul></li></ul><h2 id="UDT-socket-functions"><a href="#UDT-socket-functions" class="headerlink" title="UDT socket functions"></a>UDT socket functions</h2><ul><li>perfmon</li><li>其他的大部i分都跟传统的socket编程的api一致</li></ul><h2 id="CC-Base-Class"><a href="#CC-Base-Class" class="headerlink" title="CC Base Class"></a>CC Base Class</h2><ul><li><p>ccc.h文件定义了父类</p></li><li><p>app/cc.h里面定义了一个基于CCC的拥塞控制方法，是一个good tutorial</p></li><li><p>注意事项</p><ul><li>不要在CCC内部或者它的继承类中调用regular UDT API, 会有未知错误发生</li><li>CCCFactory&lt;…&gt;  是一个C++模板，不需要用类去继承他</li><li>UDT不会立马释放CCCFactory&lt;…&gt;的实例，应该在application类里面释放，只要是在setsockopt（）后就可以</li></ul></li></ul><h1 id="一些中途冒出来的想法"><a href="#一些中途冒出来的想法" class="headerlink" title="一些中途冒出来的想法"></a>一些中途冒出来的想法</h1><p>正如Sigcomm‘2020所示，我们的主机开销也算是延迟的一部分，那么我们的算法的耗时会不会影响整个delay的状况呢 ? </p><h1 id="代码疑惑"><a href="#代码疑惑" class="headerlink" title="代码疑惑"></a>代码疑惑</h1><ul><li><p><input disabled="" type="checkbox">  为什么可以不提前声明，也不include。虽然queue.h确实是在之前被编译的，但是这个就不需要指明依赖关系么</p><img src="C:\Users\hesy\AppData\Roaming\Typora\typora-user-images\image-20200926102437531.png" alt="image-20200926102437531" style="zoom: 50%;" /></li><li><p><input disabled="" type="checkbox">  又用到工厂模式了，可惜我还是不会（ 不过也不是重点，回头看下</p></li><li><p><input disabled="" type="checkbox">  之前master说TCP buffer不需要很大，不停poll就行？？ why ?没有很理解</p></li><li><p><input disabled="" type="checkbox">  用sourceCode整理一下代码结构</p></li></ul>]]></content>
    
    <summary type="html">
    
      UDT架构
    
    </summary>
    
    
      <category term="Codes" scheme="http://yoursite.com/categories/Codes/"/>
    
    
      <category term="Network" scheme="http://yoursite.com/tags/Network/"/>
    
      <category term="Congestion Control" scheme="http://yoursite.com/tags/Congestion-Control/"/>
    
  </entry>
  
  <entry>
    <title>socket编程</title>
    <link href="http://yoursite.com/2020/09/22/Codes/socket%E7%BC%96%E7%A8%8B/"/>
    <id>http://yoursite.com/2020/09/22/Codes/socket%E7%BC%96%E7%A8%8B/</id>
    <published>2020-09-22T22:35:59.000Z</published>
    <updated>2020-10-21T19:24:32.693Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h1><ul><li><p>《Linux系统编程、网络编程》第10章 网络编程视频课程 ,which is in my Baidu Cloud</p><blockquote><p>目前看到12了，其他的组会上听吧</p></blockquote></li><li><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMVJKNDExQjc2MS8/c3BtX2lkX2Zyb209MzMzLjc4OC52aWRlb2NhcmQuMQ==">这个b站视频<i class="fa fa-external-link-alt"></i></span>似乎是专门讲Unix网络编程这本书的</p></li><li><p><input disabled="" type="checkbox">  百度云里面存了一个系列视频，我觉得也不错</p></li></ul><h1 id="API"><a href="#API" class="headerlink" title="API"></a>API</h1><ul><li>socket就是一个文件描述符，但是没有文件名（Linux有七种文件描述符）</li></ul><h2 id="bind"><a href="#bind" class="headerlink" title="bind( )"></a>bind( )</h2><ul><li>bind ( int sockfd ,  const struct sockaddr *addr , socklen_t addrlen  )</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span>  <span class="keyword">short</span>  sa_family;     <span class="comment">/* address family, AF_xxx */</span></span><br><span class="line">    <span class="keyword">char</span>  sa_data[<span class="number">14</span>];                 <span class="comment">/* 14 bytes of protocol address */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">sockaddr_in</span> &#123;</span></span><br><span class="line">    <span class="keyword">short</span> <span class="keyword">int</span> sin_family;              <span class="comment">/* Address family */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> sin_port;       <span class="comment">/* Port number */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span>           <span class="comment">/* Internet address */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> sin_zero[<span class="number">8</span>];    <span class="comment">/*padding to be the same size as struct sockaddr*/</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><ul><li><p>因为sockaddr中直接在char[] 里面写端口和ip比较麻烦，所以用了sockaddr_in, which是分开来记录的</p><blockquote><p>这里sin的意思就是：s代表sockaddr ， in就是sockaddr_in后缀的in的意思</p><p>sin_addr存储的是ipv4的地址 ，acutually就只有32位的 unsigned int ，s_addr 【这个起名真是绕人啊…】</p><p>姑且认为，这里sockaddr_in里面的in代表着是包含在sockaddr内部的</p></blockquote><p>将sockaddr_in强制转换成sockaddr，看到有人这么写：(struct sockaddr*) &amp;sockaddr_in , ==感觉很神奇？不知道理由是什么==</p></li></ul><h2 id="epoll"><a href="#epoll" class="headerlink" title="epoll( )"></a>epoll( )</h2><ul><li><p><strong>epoll的过程</strong></p><ul><li><p>创建红黑树    <strong>epoll_create</strong>( int size)</p><blockquote><p>现在内核已经优化到size写一个大于0的数即可</p></blockquote></li><li><p>向树上增加要监听的文件描述符（已经上树了的就不用再上树了）</p><p><strong>epoll_ctl</strong> ( int epfd,  int op, int fd, struct epoll_event* event )</p><blockquote><p><strong>epfd</strong>  红黑树的根节点</p><p><strong>op</strong> 对红黑树的修改操作</p><pre><code>* EPOLL_CTL_ADD  上树 * EPOLL_CTL_MOD  修改* EPOLL_CTL_DEL 下树 </code></pre><p><strong>fd</strong> 要上树的文件描述符</p><p><strong>event</strong>  要监听该文件描述符的什么操作</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">union</span> epoll_data &#123;</span><br><span class="line">   <span class="keyword">void</span>    *ptr;</span><br><span class="line">   <span class="keyword">int</span>      fd;</span><br><span class="line">   <span class="keyword">uint32_t</span> u32;</span><br><span class="line">   <span class="keyword">uint64_t</span> u64;</span><br><span class="line">&#125; <span class="keyword">epoll_data_t</span>;  <span class="comment">// 一般就用上面两个</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">   <span class="keyword">uint32_t</span> events; <span class="comment">/*Epoll events,e.g.EPOLLIN,EPOLLOUT(也主要是这两个事件)*/</span></span><br><span class="line">   <span class="keyword">epoll_data_t</span> data;      <span class="comment">/* User data variable */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>细节</strong>：在上树的时候，每个节点既包含了文件描述符fd的信息，又包含了event的信息</p></blockquote></li><li><p>监听节点  <strong>epoll_wait</strong>( int epfd, struct epoll_event *events,int maxevents, int timeout )</p><ul><li>events提供了一个用于存放返回值的数组</li><li>maxevents提供了数组的大小</li><li>返回值是 返回的事件的个数</li></ul></li></ul></li></ul><ul><li><input disabled="" type="checkbox"> epoll反应堆</li></ul><h2 id="setsockopt"><a href="#setsockopt" class="headerlink" title="setsockopt( )"></a>setsockopt( )</h2><ul><li>在创建socket之后，bind之前设定（比如说SO_REUSEADDR）<ul><li>SO_REUSEADDR 端口复用，为何可以端口复用？可以参考下<span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uaW0vZW50cnkvNjg0NDkwMzUwOTYyNDY1MTc5MA==">这篇博客<i class="fa fa-external-link-alt"></i></span>提出的理由</li></ul></li></ul><h2 id="tl-dr"><a href="#tl-dr" class="headerlink" title="tl;dr"></a>tl;dr</h2><ul><li><input disabled="" type="checkbox"> ==看完了<span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMVJKNDExQjc2MT9wPTU2">P56 epoll反应堆<i class="fa fa-external-link-alt"></i></span>==，觉得这个系列视频讲得蛮好的，有空要接着看。</li></ul><h1 id="字节序转换"><a href="#字节序转换" class="headerlink" title="字节序转换"></a>字节序转换</h1><ul><li><p>主机字节序  无论是大端还是小端  本机的字节序就叫主机字节序</p></li><li><p>htonl  这里的l 是long ，32位 ; htons 这里的s是 short ，16位。无论是long还是short ，都是大端的</p><p><strong>htonl</strong> 用于转换ip地址（4个字节）  –》 attention 这里的ip地址是数值形式的（而非点分十进制）</p><p><strong>htons</strong> 用于转换端口号（2个字节）</p><blockquote><p>host to numerical long , host to numerical short</p></blockquote></li><li><p><strong>inet_pton</strong></p><p>将ip地址从点分十进制( point )转换为大端的数值( numerical )形式</p><p><strong>inet_ntop</strong></p></li><li><p>网络编程中尽量都用无符号的 ，不然一不小心出现负值</p></li></ul><h1 id="五大IO模型"><a href="#五大IO模型" class="headerlink" title="五大IO模型"></a>五大IO模型</h1><h2 id="阻塞IO-BIO"><a href="#阻塞IO-BIO" class="headerlink" title="阻塞IO BIO"></a>阻塞IO BIO</h2><p>应用层accept( ) –&gt;  内核recvFrom( <strong>Block</strong>，…  ) 取一个socket</p><p>​            |</p><p>​            V</p><p>应用层read( ) –&gt;内核 recvFrom( <strong>Block</strong>，… ) 取字节流</p><p>​            |</p><p>​            V</p><p>​            ….</p><ul><li>如果accept的时候没有客户端连接上来，那么就卡在这一步，不会往下行进了</li><li>另一方面，如果此时有别的连接进来了，也不会搭理，因为线程阻塞在其中某个步骤中了‘<ul><li>没有办法处理多个客户端连接的情况</li></ul></li></ul><h2 id="非阻塞IO-基于线程驱动模型"><a href="#非阻塞IO-基于线程驱动模型" class="headerlink" title="非阻塞IO   基于线程驱动模型"></a>非阻塞IO   基于线程驱动模型</h2><p>应用层accept( ) –&gt; 内核recvFrom( <strong>nonBlock</strong>，… ) 取一个socket</p><p>​            |</p><p>​            V</p><p>应用层read( ) –&gt; 内核recvFrom( <strong>nonBlock</strong>，… ) 取字节流</p><p>​            |</p><p>​            V</p><p>​            ….</p><ul><li>如果有客户端进来，我可以都处理–&gt;实际上是利用非阻塞的性质，一个函数没有获得结果，我还是可以往下走，keep循环走这个流程</li></ul><h2 id="IO多路复用-NIO-new-IO-基于事件驱动模型"><a href="#IO多路复用-NIO-new-IO-基于事件驱动模型" class="headerlink" title="IO多路复用 NIO new IO   基于事件驱动模型"></a>IO多路复用 NIO new IO   基于事件驱动模型</h2><blockquote><p>New IO是java的一个包，which includes socketChannel,ByteBuffer，Nonblocking IO是Linux操作系统的非阻塞IO</p></blockquote><ul><li>多路复用器 应用层select( ) –&gt; 内核epoll( )</li></ul><p><img src="https://images.weserv.nl/?url=https://gitee.com/HesyH/Image-Hosting/raw/master/image4typora/202009/26/145842-614824.png" alt="image-20200926145841363"></p><pre><code>* epoll的过程是非阻塞的，但是处理数据的过程是阻塞的（当然还是得遍历，一个一个去处理）* 此外，epoll做了优化，不用把数据从内核空间拷贝到用户空间了，采用内存地址的方式，实现了“零拷贝”</code></pre><h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><ul><li><p><strong>channel</strong></p><ul><li><p>BIO读写都是单向的</p><img src="C:\Users\hesy\AppData\Roaming\Typora\typora-user-images\image-20200926150226860.png" alt="image-20200926150226860" style="zoom:67%;" /><p>但是NIO是双向的（利用channel）</p><img src="C:\Users\hesy\AppData\Roaming\Typora\typora-user-images\image-20200926151233132.png" alt="image-20200926151233132" style="zoom:67%;" /><p>且在byte数组基础上还包装成了bytebuffer</p><blockquote><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vY2hlbnBpL3AvNTM3Mjc4Ni5odG1s">bytebuffer与channel的交互<i class="fa fa-external-link-alt"></i></span></p></blockquote></li></ul></li><li><p><strong>selector</strong></p></li></ul><h2 id="NIO-reactor模型-反应堆模型"><a href="#NIO-reactor模型-反应堆模型" class="headerlink" title="NIO reactor模型  反应堆模型"></a>NIO reactor模型  反应堆模型</h2><ul><li>单线程</li><li>多线程</li><li>主从模型</li></ul>]]></content>
    
    <summary type="html">
    
      socket编程中API整理
    
    </summary>
    
    
      <category term="Codes" scheme="http://yoursite.com/categories/Codes/"/>
    
    
      <category term="Network" scheme="http://yoursite.com/tags/Network/"/>
    
  </entry>
  
  <entry>
    <title>gcc链接梳理</title>
    <link href="http://yoursite.com/2020/09/18/Summary/LinkDebug/"/>
    <id>http://yoursite.com/2020/09/18/Summary/LinkDebug/</id>
    <published>2020-09-18T22:34:22.000Z</published>
    <updated>2020-10-21T19:24:32.693Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h1><h2 id="reference"><a href="#reference" class="headerlink" title="reference"></a>reference</h2><ul><li><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3UwMTA5MzUwNzYvYXJ0aWNsZS9kZXRhaWxzLzUxMzc0Mzg4">这个博客<i class="fa fa-external-link-alt"></i></span>写的很全</p></li><li><p>程序员的自我修养</p><blockquote><p>相关内容，自己的博客上有总结其中几章</p><ul><li><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hlc3lfSC9hcnRpY2xlL2RldGFpbHMvMTAxMTA1NTcz">chapeter 6 可执行文件(.o)及动态链接(.a)的装载与进程<i class="fa fa-external-link-alt"></i></span></p></li><li><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hlc3lfSC9hcnRpY2xlL2RldGFpbHMvMTAxMTE5Njk2">chapeter 8 Linux共享库(.so)的组织<i class="fa fa-external-link-alt"></i></span></p><blockquote><p>主要讲了一些补充的、正交的 加载相关的环境变量，方便debug编译和链接过程</p></blockquote></li></ul></blockquote></li></ul><h2 id="nm命令-–-查看二进制和符号表的利器"><a href="#nm命令-–-查看二进制和符号表的利器" class="headerlink" title="nm命令  –  查看二进制和符号表的利器"></a>nm命令  –  查看二进制和符号表的利器</h2><blockquote><p>其实还有很多常用的用来读库文件的命令，比如objdump ， readelf ,  这里不过是因为nm比较通用，所以重点介绍一下（其实觉得objdump可以出更多的信息的） </p></blockquote><ul><li><p>nm -g –defined-only libxxx.a # -g 查看外部符号表 ，也是–extern-only</p><blockquote><img src="https://gitee.com/HesyH/Image-Hosting/raw/master/image4typora/202009/18/224322-528256.png" alt="image-20200918224319703" style="zoom: 67%;" /></blockquote><p>  会把.a文件是从<strong>哪些.o文件</strong>中打包过来以及<strong>对应吸收了哪些符号</strong>都标清楚。</p></li></ul><h2 id="a-libxxxx-a-archive-和-so-libxxxx-so-major-minor-shared-object-的区别"><a href="#a-libxxxx-a-archive-和-so-libxxxx-so-major-minor-shared-object-的区别" class="headerlink" title=".a(libxxxx.a)[archive]和 .so(libxxxx.so.major.minor) [shared object]的区别"></a>.a(libxxxx.a)[archive]和 .so(libxxxx.so.major.minor) [shared object]的区别</h2><h3 id="生成"><a href="#生成" class="headerlink" title="生成"></a><strong>生成</strong></h3><ol><li><p>生成<strong>静态库</strong>使用ar工具，其实ar是archive的意思</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ar cqs libhello.a hello.o</span><br></pre></td></tr></table></figure><p>​    静态库与汇编生成的目标文件一起链接为可执行文件，那么静态库必定跟.o文件格式相似。其实一个静态库可以简单看成是<strong>一组目标文件</strong>（.o/.obj文件）的集合，即很多目标文件经过压缩打包后形成的一个文件。（这里cqs是静态库的名称，别搞混了）</p></li><li><p>生成<strong>动态库</strong>用gcc来完成，由于可能存在多个版本，因此通常指定版本号：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一步</span></span><br><span class="line">g++ -fPIC -o DynamicMath.o DynamicMath.cpp</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二步</span></span><br><span class="line">g++ -shared -o libhello.so.1.0 DynamicMath.o</span><br><span class="line"></span><br><span class="line"><span class="comment"># 合起来就是</span></span><br><span class="line">g++ -fPIC -shared -o libhello.so.1.0 DynamicMath.o.cpp</span><br></pre></td></tr></table></figure></li></ol><ul><li><p>-shared: 表示生成的是动态链接库</p><p>-fPIC: 生成位置独立的代码，用于编译共享库。在任意内存空间都可以被加载</p><p>-Wall: 生成所有警告信息</p><p>前两个是必加的参数，最后一个有时候会加</p></li></ul><h3 id="查看"><a href="#查看" class="headerlink" title="查看"></a><strong>查看</strong></h3><ul><li><p><strong>查看静态库包含了哪些.o文件也很简单</strong>：</p><ul><li><p>nm -g 命令 （上文） 还会列出符号表 </p></li><li><p>ar -t llibxx.a  ( display a <u>table</u> listing contents of the archive )</p><blockquote><img src="https://gitee.com/HesyH/Image-Hosting/raw/master/image4typora/202009/18/230631-588422.png" alt="image-20200918230630480" style="zoom:67%;" /></blockquote></li></ul></li><li><p>查看<strong>动态库</strong>包含了哪些文件</p><ul><li><p>目前没有找到办法查看，只能使用<strong>nm -D xx.so</strong>的方式去查看动态库的动态符号表</p><ul><li>注意，nm的-D参数只对动态库有效</li></ul></li></ul></li></ul><h3 id="调用-–》被载入的时刻不同-最主要的区别在于此"><a href="#调用-–》被载入的时刻不同-最主要的区别在于此" class="headerlink" title="调用 –》被载入的时刻不同 [最主要的区别在于此]"></a><strong>调用</strong> –》被载入的时刻不同 [<strong>最主要的区别</strong>在于此]</h3><ul><li><p>静态库的代码在编译过程中已经被载入可执行程序，因此体积较大</p></li><li><p>共享库(动态库)的代码是在可执行程序运行时才载入内存的，在编译过程中仅简单的引用，因此代码体积较小。</p></li><li><p>共享库(动态库)的好处是，不同的应用程序如果调用相同的库，那么在内存里只需要有一份该共享库的实例。【这就是共享库诞生的原因之一，另一点就是静态库需要全量更新，但是动态库只需要增量更新】</p></li></ul><ul><li><p><strong>调用命令</strong> 都是一致的</p><p>gcc -L紧跟目录名字 -l紧跟库名字, e.g. </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -o hello main.c -L. -lmyhello</span><br></pre></td></tr></table></figure><blockquote><p>-L表示搜寻库的目录，-I表示依赖库的名称（这里是L的小写，表示lib）。这个应该都知道把…</p><p>-I（这里是i的大写）（inlcude的意思） 这里用不到，但是也经常用，就直接补充下把，是头文件(.h)所在的路径  </p></blockquote><ul><li><p>请注意，==-lxx一定要写在最后面==，因为gcc的命令是从左到右执行的，被依赖项得放在右边，因为是先解析main.c然后看到里面有一些外部的符号，which是在myhello这个库里面的，然后就往右边解析去寻找这个符号</p><ul><li><p>为什么这么做就很明了， 按需取你需要的符号，which means 没必要把整个myhello库都加载进内存或者集成到最终的hello可执行文件中</p></li><li><p>如果有循环依赖( libA.a&lt;–&gt;libB.so )，那么也要反复写依赖库， which means要写成gcc -IA -IB -IA</p></li></ul></li><li><blockquote><p>gcc -lmath -c test.cc -o test.o  <strong>[ x ]</strong><br>gcc -c test.cc -o test.o -lmath  <strong>[ √ ]</strong></p></blockquote></li><li><p>动态静态库都存在的时候，优先使用.so文件（毕竟动态库开销小、跨平台）</p><blockquote><p>如果想链接的就是动态库的话，就用如下参数：-WI,-Bstatic</p><p>关于WI参数和Bstatic的用法，可以参考<span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzIyOTQwMDQ4">这个回答<i class="fa fa-external-link-alt"></i></span></p><p>进一步，使用WI指定链接的soname可以参考<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmdfaHVmZW5nL2FydGljbGUvZGV0YWlscy81Mzg5OTEyMA==">这个<i class="fa fa-external-link-alt"></i></span></p></blockquote></li><li><p>动态库链接和运行时加载的过程是分开的，所以有时候链接的时候成功了，但是运行起来还是会报找不到符号表的错误</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-LsoLibPath  <span class="comment"># 链接时的路径</span></span><br><span class="line">-WI,rpath=soLibPath  <span class="comment"># 链接时指定的参数，用于运行时加载的路径</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="链接时的默认搜索顺序、搜索路径"><a href="#链接时的默认搜索顺序、搜索路径" class="headerlink" title="链接时的默认搜索顺序、搜索路径"></a>链接时的默认搜索顺序、搜索路径</h3><h4 id="静态库"><a href="#静态库" class="headerlink" title="静态库"></a>静态库</h4><p>搜索顺序：</p><ol><li><p>GCC命令中的参数 -L</p><ol start="2"><li>gcc的环境变量LIBRARY_PATH</li><li>内定目录 /lib /usr/lib /usr/local/lib 这是当初compile gcc时写在程序内的</li></ol></li></ol><h4 id="动态库"><a href="#动态库" class="headerlink" title="动态库"></a>动态库</h4><ol><li><p>GCC命令中的参数 -L</p></li><li><p>环境变量LD_LIBRARY_PATH指定的动态库搜索路径</p></li><li><p>配置文件/etc/ld.so.conf中指定的动态库搜索路径</p></li><li><p>默认的动态库搜索路径 /lib 和 /usr/lib</p><blockquote><p>/lib 或 /usr/lib（64位系统下为/lib64 /usr/lib64）路径下的共享库比较特殊。 </p><p>a) 它是默认的共享库的搜索路径。 </p><p>b) 它没有放到/etc/ld.so.conf 文件中。但是在/etc/ld.so.cache 的缓存中有它。 </p><p>c) 其路径下的共享库的变动<strong>即时生效</strong>，不用执行ldconfig。就算缓存ldconfig -p 中没有，新加入的动态库也可以执行。</p></blockquote></li></ol><h3 id="小总结"><a href="#小总结" class="headerlink" title="小总结"></a>小总结</h3><ul><li>其实会发现，路径的配置都是遵循着一个从小到大，从内到外的顺序（就跟局部变量和全局变量一样）</li></ul><h2 id="ldconfig"><a href="#ldconfig" class="headerlink" title="ldconfig"></a>ldconfig</h2><p>==注意，这是针对<strong>动态库</strong>的<strong>加载时路径</strong>的配置，<strong>和编译的路径无关</strong>==</p><ul><li><p>/etc/ld.so.conf 是指定动态库搜索路径的一个配置文件</p><blockquote><p>一般cat出来，里面的内容就是：<code>include /etc/ld.so.conf.d/*.conf</code></p><p>这意味着，具体的动态库搜索路径还是由/etc/ld.so.conf.d里面的conf文件决定，简单看下这个文件夹里面有些什么：</p><p><img src="https://images.weserv.nl/?url=https://gitee.com/HesyH/Image-Hosting/raw/master/image4typora/202009/24/172716-465653.png" alt="image-20200924172715424"></p></blockquote></li><li><p>/etc/ld.so.conf.d</p><p>简单看下这个文件夹里面有些什么：</p><p><img src="https://images.weserv.nl/?url=https://gitee.com/HesyH/Image-Hosting/raw/master/image4typora/202009/24/172716-465653.png" alt="image-20200924172715424"></p><p>实际上这是各个安装文件在安装时会自带的config文件，所有的配置集合最终会在ldconfig.so.cache里面存放</p><p>所以<strong>一般安装完一个文件</strong>，都会在ldconfig.so.conf.d文件夹里面更新相应的xx.config文件，这时候<strong>要使用ldconfig命令进行对ldconfig.so.cache文件的更新</strong>，which work according to ldconfig.so.conf , which will traverse ldconfig.so.d recursively to get the *.so/*.a files and record into teh cache file.</p></li><li><p>程序运行时加载库的时候，最终就是从<strong>ldconfig.so.cache</strong>这个文件里面去找</p><blockquote><p>这是一个二进制文件，没法直接查看，但是可以通过ldconfig -p去查看</p></blockquote></li><li><p><strong>ldconfig</strong></p><ul><li><p>当把库安装在/lib或者/usr/lib等默认的搜索路径以后，需要手动修改ld.so.conf文件添加对应路径，然后再调用ldconfig去更新cache文件</p><ul><li>注意，有root权限才可以修改ld.so.conf以及调用ldconfig进行对/etc/ldconfig.so.cache的更新</li></ul></li><li><p>没有root权限的时候就是采用修改环境变量LD_LIBRARY_PATH的方式 或者 编译时候添加参数( -WI,rpath=xxx )  </p><blockquote><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">rpath</span> <span class="string">-- running path</span></span><br><span class="line"><span class="attr">Wl</span> <span class="string">的l 代表的是把后面的数传递给链接器(ld) </span></span><br></pre></td></tr></table></figure></blockquote><ul><li>注意，添加-L编译参数的方法属于链接路径，ldconfig管的是加载时路径，这两个不要混肴了</li><li>-WI参数和-Xlinker参数的区别可以看<span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vcmlja3lrL3AvNDE4NjkwMi5odG1s">这个博客<i class="fa fa-external-link-alt"></i></span></li></ul></li><li><p>其他参数</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ldconfig -p 查看共享库的缓存内容 ( <span class="built_in">print</span> ld.config.cache )</span><br><span class="line">ldconfig -n 在当前文件夹下创建软链接，后面编译链接的时候还得加个-L路径参数指向这个文件夹</span><br><span class="line">ldconfig主要的作用是根据/etc/ld.so.conf 的内容，查找内容中所包含目录下实际的动态库文件，生成搜索共享库的缓存文件/etc/ld.so.cache</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="小心得"><a href="#小心得" class="headerlink" title="小心得"></a>小心得</h3><ul><li><p>安装完新的库之后，不管三七二十一，ldconfig一下</p></li><li><p>一开始我很好奇为什么要引入一个/etc/ld.so.cache，搞得那么麻烦。看到有资料是这么说的：</p><blockquote><p>linux下的共享库机制采用了类似于高速缓存的机制，将库信息保存在/etc/ld.so.cache里边</p></blockquote></li></ul><h2 id="ldd-ld-dependency"><a href="#ldd-ld-dependency" class="headerlink" title="ldd (ld dependency)"></a>ldd (ld dependency)</h2><ul><li><input checked="" disabled="" type="checkbox"> <span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vc2RkYWkvcC8xMDM5NzUxMC5odG1s">ldd原理介绍<i class="fa fa-external-link-alt"></i></span> （最下方） </li></ul><p>例子：</p><p>ldd /usr/bin/passwd  得到返回：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">NTP-slave:/usr/<span class="built_in">local</span>/openssl/lib </span><br><span class="line">linux-vdso.so.1 =&gt;  (0x00007fff15dff000)</span><br><span class="line">libpam.so.0 =&gt; /lib64/libpam.so.0 (0x00007fce5eb4b000)</span><br><span class="line">libldap-2.4.so.2 =&gt; /usr/lib64/libldap-2.4.so.2 (0x00007fce5e901000)</span><br><span class="line">        ...省略...</span><br><span class="line">libcrypto.so.0.9.8 =&gt; /usr/lib64/libcrypto.so.0.9.8 (0x00007fce5cefc000)</span><br><span class="line">/lib64/ld-linux-x86-64.so.2 (0x00007fce5f1a3000)</span><br><span class="line">libz.so.1 =&gt; /lib64/libz.so.1 (0x00007fce5cce5000)</span><br></pre></td></tr></table></figure><p>第一列：程序需要依赖什么库<br>第二列: 系统提供的与程序需要的库所对应的库<br>第三列：库加载的开始地址</p><p>通过上面的信息，我们可以得到以下几个信息：<br>1.通过对比第一列和第二列，我们可以分析程序需要依赖的库和系统实际提供的，是否相匹配<br>2.通过观察第三列，我们可以知道在当前的库中的符号在对应的进程的地址空间中的开始位置<br>如果依赖的某个库找不到，通过这个命令可以迅速定位问题所在</p><ul><li>是一个脚本而不是程序</li></ul><h1 id="待整理"><a href="#待整理" class="headerlink" title="待整理"></a>待整理</h1><ul><li><p><span class="exturl" data-url="aHR0cDovL3d3dy5qZWVweGllLm5ldC9hcnRpY2xlLzg4NDU2MC5odG1s">符号表的含义<i class="fa fa-external-link-alt"></i></span>  &amp; <span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbGl1eWFueWd6L3AvNTUzNjYwNy5odG1s">还有这个<i class="fa fa-external-link-alt"></i></span></p><ul><li><p>mangle</p><blockquote><p>恢复mangle后的函数名称使用<strong>c++filt</strong>命令即可,e.g.</p><img src="C:\Users\hesy\AppData\Roaming\Typora\typora-user-images\image-20200925114818204.png" alt="image-20200925114818204" style="zoom: 80%;" /></blockquote></li><li><p>U是未定义，which means 是调用外界的函数（在其它库中定义的），T(位于text section)表示函数是当前库中定义的，W(weak)类是当前库中定义，被其它库中的函数覆盖），B(位于bss section)</p></li><li><p>nm -n 按照地址排列符号 （–numeric sort )</p></li><li><p>nm -u 打印未定义符号 （ldd -r xx.so 也可以）</p></li></ul></li><li><p><input checked="" disabled="" type="checkbox">  终于明白了为什么makefile里面有的地方不需要.h，有的地方需要了</p><img src="https://gitee.com/HesyH/Image-Hosting/raw/14ac540fae3bfde3bbaa6b7025ac4d365650fa7f/image4typora/202010/05/000501-970705.png"/><p>​    写在依赖里面是为了及时的更新，是makefile的特性，跟gcc和g++的命令无关。本身cc -E 里面就会处理头文件的事情，which means 头文件不需要我们手动去指定依赖，其实代码里面写的很清楚了，编译器是知道的，而且结果很明显，确实是知道的（详见阮一峰的博客：<span class="exturl" data-url="aHR0cDovL3d3dy5ydWFueWlmZW5nLmNvbS9ibG9nLzIwMTQvMTEvY29tcGlsZXIuaHRtbA==">编译器的工作过程<i class="fa fa-external-link-alt"></i></span>中的“第五步 预处理”的剖析）</p></li></ul><h1 id="question"><a href="#question" class="headerlink" title="question"></a>question</h1><ul><li><p><input disabled="" type="checkbox">  静态链接和动态链接都是ld么</p><blockquote><p>目前我的理解是：</p><p>ld是静态链接器，动态链接器实际上是ld-linux.so（ 具体看机子</p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      动态链接和静态链接
    
    </summary>
    
    
      <category term="Summary" scheme="http://yoursite.com/categories/Summary/"/>
    
    
      <category term="Compilation and Link" scheme="http://yoursite.com/tags/Compilation-and-Link/"/>
    
  </entry>
  
  <entry>
    <title>Summary of makefile</title>
    <link href="http://yoursite.com/2020/09/17/Summary/makeFileSummary/"/>
    <id>http://yoursite.com/2020/09/17/Summary/makeFileSummary/</id>
    <published>2020-09-17T17:18:59.000Z</published>
    <updated>2020-10-21T19:24:32.693Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="refer"><a href="#refer" class="headerlink" title="refer"></a>refer</h1><ul><li><span class="exturl" data-url="aHR0cHM6Ly9zZWlzbWFuLmdpdGh1Yi5pby9ob3ctdG8td3JpdGUtbWFrZWZpbGUvaW50cm9kdWN0aW9uLmh0bWw=">陈皓：跟我一起写makefile<i class="fa fa-external-link-alt"></i></span></li></ul><h2 id="others-拓展"><a href="#others-拓展" class="headerlink" title="others[拓展]"></a>others[拓展]</h2><ul><li><input checked="" disabled="" type="checkbox"> <span class="exturl" data-url="aHR0cHM6Ly9jb29sc2hlbGwuY24vYXJ0aWNsZXMvMzc5MC5odG1s">陈皓：如何调试MAKEFILE变量<i class="fa fa-external-link-alt"></i></span><ul><li>makefile中的origin函数 等等， 在这里又介绍了几个自带的函数</li><li>陈皓自己写了个用于debug的mk</li><li>make的f参数，指定特定名称的文件，多个参数一起用，会连接起来传递给程序一起执行</li><li>还附上了一个remake tool的教程，which tl;dr ，以后再说吧</li></ul></li></ul><h1 id="basis"><a href="#basis" class="headerlink" title="basis"></a>basis</h1><ul><li><p>Makefile里主要包含了五个东西：显式规则、隐晦规则(自动推导)、变量定义、文件指示(makefile里面包含别的makefile 以及 其他一些规则)和注释(#)</p></li><li><p>Makefile最灵魂的东西就是：</p></li><li><p>如果目标(<target>)不存在 <strong>或者</strong> prerequisites的日期新于目标，就执行相应的command</p></li><li><p>make的<strong>工作方式</strong></p>  <figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GNU的make工作时的执行步骤如下：（想来其它的make也是类似）</span><br><span class="line"><span class="number">1.</span> 读入所有的Makefile。</span><br><span class="line"><span class="number">2.</span> 读入被include的其它Makefile。</span><br><span class="line"><span class="number">3.</span> 初始化文件中的变量。</span><br><span class="line"><span class="number">4.</span> 推导隐晦规则，并分析所有规则。</span><br><span class="line"><span class="number">5.</span> 为所有的目标文件创建依赖关系链。</span><br><span class="line"><span class="number">6.</span> 根据依赖关系，决定哪些目标要重新生成。</span><br><span class="line"><span class="number">7.</span> 执行生成命令。</span><br></pre></td></tr></table></figure><ul><li>两个阶段<ul><li>lazy展开（有点python的意思</li></ul></li></ul></li></ul><h2 id="trivial-points"><a href="#trivial-points" class="headerlink" title="trivial points"></a>trivial points</h2><ul><li>.PHONY 伪目标<ul><li>clean命令放最后，因为最前的是默认的总目标</li><li><span class="exturl" data-url="aHR0cHM6Ly9zZWlzbWFuLmdpdGh1Yi5pby9ob3ctdG8td3JpdGUtbWFrZWZpbGUvcnVsZXMuaHRtbA==">伪目标的巧用<i class="fa fa-external-link-alt"></i></span> –》 [ 单独一个make可以work的原理 ]</li></ul></li><li>命令前的小减号 , 出现错误只会弹警告，然后继续运行，不会退出  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-include &lt;filename&gt;   <span class="comment"># 找不到就不用找了</span></span><br><span class="line">-rm edit $(objects)   <span class="comment"># 删除失败就就继续执行吧</span></span><br></pre></td></tr></table></figure></li><li><strong>自动推导</strong> [隐晦规则]<br>  在生成xx.o的过程中可以省去gcc -c xx.c的命令</li><li><strong>另类风格</strong><br>  文件依赖关系会显得有点凌乱，但是会让makefile变得简单<br>  简而言之，就是一个xx.o可以在多行的左边出现</li><li>make -f / make –file 指定除了makefile 和Makefile以外的别的命名方式</li><li>寻找别的makefile的目录<ul><li>系统缺省的目录</li><li>-I / –include-dir 指定的目录</li><li>VPATH变量 &amp; 更灵活的vpath （in whose pattern我们应该用%而不是*的通配符），目录之间使用冒号(:)分隔</li><li>环境变量MAKEFILES<ul><li>不建议使用</li></ul></li></ul></li></ul><h2 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h2><ul><li>一般来说，make会以UNIX的标准Shell，也就是 /bin/sh 来执行命令。</li><li>命令要缩进(tab)</li></ul><h1 id="书写命令"><a href="#书写命令" class="headerlink" title="书写命令"></a>书写命令</h1><blockquote><p>每条规则中的命令和操作系统Shell的命令行是一致的。make会<strong>按顺序一条一条的执行命令会</strong>，每条命令的开头必须以 Tab 键开头，除非，命令是紧跟在依赖规则后面的分号后的。在命令行之间中的空格或是空行会被忽略，但是如果该空格或空行是以Tab键开头的，那么make会认为其是一个空命令。</p></blockquote><ul><li><p>注意点！</p><ul><li>如果你要让上一条命令的结果应用在下一条命令时，你应该使用分号分隔这两条命令。比如你的第一条命令是cd命令，你希望第二条命令得在cd之后的基础上运行，那么你就<strong>不能把这两条命令写在两行上</strong>，而应该把这两条命令写在一行上，用分号分隔</li></ul></li><li><p>全局参数</p><ul><li>debug<ul><li>–just-print / -n</li><li>-s / –silent / –quiet</li></ul></li><li>-i / –ignore-errors<ul><li>.IGNORE为目标的规则 是另一种级别的防止命令出错的方式</li></ul></li><li>-k / –keep-going</li><li>-w / –print-directory<ul><li>-C 的时候自动打开-w</li><li>-s的时候-w总是失效的</li></ul></li></ul></li></ul><h2 id="嵌套执行make"><a href="#嵌套执行make" class="headerlink" title="嵌套执行make"></a>嵌套执行make</h2><ul><li>总控Makefile , subsystem</li><li>变量传递<ul><li>传递变量到下层用export<ul><li>后面什么都不跟，表示传递所有的变量</li></ul></li><li>SHELL 和 MAKEFLAGS 不管你是否export，其总是要传递到下层 Makefile中<ul><li>MAKEFLAGS如果是自己定义的，得确保其中的选项是大家都会用到的。如果其中有 -t , -n 和 -q 参数，容易出现让人意想不到的结果</li></ul></li><li>make命令中的有几个参数并不往下传递</li><li>不想往下层传递参数的话：<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">subsystem:</span></span><br><span class="line">cd subdir &amp;&amp; <span class="variable">$(MAKE)</span> MAKEFLAGS=</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="命令包"><a href="#命令包" class="headerlink" title="命令包"></a>命令包</h2><ul><li>调用的时候和调用变量一样的方式  </li></ul><h1 id="条件判断和函数"><a href="#条件判断和函数" class="headerlink" title="条件判断和函数"></a>条件判断和函数</h1><h2 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h2><ul><li><p>格式</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;conditional-directive&gt;</span><br><span class="line">&lt;text-if-true&gt;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&lt;text-if-false&gt;</span><br><span class="line"><span class="keyword">endif</span></span><br></pre></td></tr></table></figure></li><li><p>命令</p><ul><li><p>ifeq &amp; ifneq</p>  <figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ifeq</span> (&lt;arg1&gt;, &lt;arg2&gt;)</span><br><span class="line"><span class="keyword">ifeq</span> &#x27;&lt;arg1&gt;&#x27; &#x27;&lt;arg2&gt;&#x27;</span><br><span class="line"><span class="keyword">ifeq</span> <span class="string">&quot;&lt;arg1&gt;&quot;</span> <span class="string">&quot;&lt;arg2&gt;&quot;</span></span><br><span class="line"><span class="keyword">ifeq</span> <span class="string">&quot;&lt;arg1&gt;&quot;</span> &#x27;&lt;arg2&gt;&#x27;</span><br><span class="line"><span class="keyword">ifeq</span> &#x27;&lt;arg1&gt;&#x27; <span class="string">&quot;&lt;arg2&gt;&quot;</span>        </span><br></pre></td></tr></table></figure></li><li><p>ifdef &amp; ifndef</p><ul><li>ifdef只是测试一个变量是否有值，其并不会把变量扩展到当前位置。*</li></ul></li></ul></li><li><p>注意点<br>  <strong>make是在读取Makefile时就计算条件表达式的值</strong>，并根据条件表达式的值来选择语句，所以，不要把自动化变量（如 $@ 等）放入条件表达式中，因为<strong>自动化变量是在运行时才有的</strong>。</p></li></ul><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(&lt;function&gt; &lt;arguments&gt;)</span><br></pre></td></tr></table></figure><ul><li><p>$(subst <from>,<to>,<text>)</p></li><li><p>$(patsubst <pattern>,<replacement>,<text>)</p><ul><li>顾名思义，不是text上的substitution了，而是pattern上的substitution</li><li>和变量替换的作用一样<blockquote><p>$(objects:.o=.c) 和 $(patsubst %.o,%.c,$(objects)) 是一样的。</p></blockquote></li></ul></li><li><p>$(strip <string>)</p></li><li><p>$(findstring <find>,<in>)</p></li><li><p>$(filter &lt;pattern…&gt;,<text>)</p></li><li><p>$(filter-out &lt;pattern…&gt;,<text>)</p></li><li><p>$(sort <list>)</p></li><li><p>$(word <n>,<text>)</p></li><li><p>$(wildcard PATTERN…) </p><ul><li><strong>在Makefile规则中，通配符会被自动展开。但在变量的定义和函数引用时，通配符将失效。这种情况下如果需要通配符有效，就需要使用函数“wildcard”</strong>。<blockquote><p>在Makefile中，它被展开为已经存在的、使用空格分开的、匹配此模式的所有文件列表。如果不存在任何符合此模式的文件，函数会忽略模式字符并返回空。需要注意的是：这种情况下规则中通配符的展开和上一小节匹配通配符的区别。</p></blockquote></li></ul></li><li><p>循环 $(foreach <var>,<list>,<text>)</p></li><li><p>判断 $(if <condition>,<then-part>)   /  $(if <condition>,<then-part>,<else-part>)</p></li><li><p>shell函数</p><blockquote><p>注意，这个函数会新生成一个Shell程序来执行命令，所以你要注意其运行性能，如果你的Makefile中有一些比较复杂的规则，并大量使用了这个函数，那么对于你的系统性能是有害的。特别是Makefile的隐晦的规则可能会让你的shell函数执行的次数比你想像的多得多。<br>… <span class="exturl" data-url="aHR0cHM6Ly9zZWlzbWFuLmdpdGh1Yi5pby9ob3ctdG8td3JpdGUtbWFrZWZpbGUvcnVsZXMuaHRtbA==">tl;dr<i class="fa fa-external-link-alt"></i></span></p></blockquote></li></ul><h1 id="书写规则"><a href="#书写规则" class="headerlink" title="书写规则"></a>书写规则</h1><ul><li>最重要的是 依赖关系 &amp; 生成目标的方法</li><li>通配符<ul><li>~ , * , ?</li><li>在目标和命令中都可以用</li></ul></li><li>多目标</li><li>静态模式语法  <figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;targets ...&gt; : &lt;target-pattern&gt; : &lt;prereq-patterns ...&gt;</span><br><span class="line">    &lt;commands&gt;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><ul><li>e.g.  <target-pattern> like %.o , <prereq-pattern> like %.c</li><li>注意，这里<target-pattern> 和<prereq-pattern> 都是一个集合，所以后面的 $&lt; 表示第一个依赖文件，会<strong>依次</strong>取出这个集合里面的所有文件</li><li>example<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">objects = foo.o bar.o</span><br><span class="line"><span class="section">all: <span class="variable">$(objects)</span></span></span><br><span class="line"><span class="variable">$(objects)</span>: %.o: %.c</span><br><span class="line">    <span class="variable">$(CC)</span> -c <span class="variable">$(CFLAGS)</span> <span class="variable">$&lt;</span> -o <span class="variable">$@</span> </span><br></pre></td></tr></table></figure></li></ul></li><li>自动生换成依赖性  <figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cc -M xx.cc </span><br><span class="line">cc -MM xx.cc </span><br></pre></td></tr></table></figure><ul><li>与源代码解耦合的方法  <ul><li>.d文件包含.c文件的依赖</li><li>makefile配置生成.d文件，然后再包含这些.d文件</li></ul></li></ul></li></ul><h1 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h1><h2 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h2><ul><li><p>命名规则</p><blockquote><p>传统的Makefile的变量名是全大写的命名方式，但我推荐使用大小写搭配的变量名，如：MakeFlags。这样可以避免和系统的变量冲突，而发生意外的事情。<br>可以是数字开头的</p></blockquote></li><li><p>调用</p><ul><li>${} 与 $() </li><li>也可以不加括号，但是加上比较安全</li></ul></li><li><p>定义 &amp; 赋值</p><ul><li><p>= </p><ul><li>右边可以是目前未定义变量</li><li>小心递归定义</li><li>避免在变量中使用函数,whcih 比较增大开</li></ul></li><li><p>:=</p><ul><li>只可以用前面定义好了的 ，所以比较安全</li></ul></li><li><p>#的用法：表示变量定义的中止</p><ul><li><p>正例</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nullstring :=</span><br><span class="line">space := <span class="variable">$(nullstring)</span> <span class="comment"># end of the line</span></span><br></pre></td></tr></table></figure><blockquote><p>nullstring是一个Empty变量，其中什么也没有，而我们的space的值是一个空格。因为在操作符的右边是很难描述一个空格的，这里采用的技术很管用，先用一个Empty变量来标明变量的值开始了，而后面采用“#”注释符来表示变量定义的终止，这样，我们可以定义出其值是一个空格的变量。</p></blockquote></li><li><p>反例</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dir := /foo/bar    <span class="comment"># directory to put the frobs in</span></span><br></pre></td></tr></table></figure><blockquote><p>dir这个变量的值是“/foo/bar”，后面还跟了4个空格，如果我们这样使用这样变量来指定别的目录——“$(dir)/file”那么就完蛋了。</p></blockquote></li><li><p>个人想法<br>  何必呢。直接回车换行，也不用#不是很好。不过也可能一方面是为了方便阅读，另一方面也是显式定义，防止不小心打了空格啥的没有看见</p></li><li><p>?=<br>  如果之前没定义过，就赋值，否则就omit</p></li></ul></li></ul></li></ul><h2 id="高级用法"><a href="#高级用法" class="headerlink" title="高级用法"></a>高级用法</h2><h3 id="变量值替换"><a href="#变量值替换" class="headerlink" title="变量值替换"></a>变量值替换</h3><ul><li>$(var:a=b) 或 ${var:a=b}<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foo := a.o b.o c.o</span><br><span class="line">bar := $(foo:.o=.c)</span><br></pre></td></tr></table></figure>另一种也能完成变量替换的级数就是 “静态模式”<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foo := a.o b.o c.o</span><br><span class="line">bar := $(foo:%.o=%.c)</span><br></pre></td></tr></table></figure></li></ul><h3 id="变量值再当作变量"><a href="#变量值再当作变量" class="headerlink" title="变量值再当作变量"></a>变量值再当作变量</h3><ul><li><p>用法</p>  <figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">x = y</span><br><span class="line">y = z</span><br><span class="line">a := $(<span class="variable">$(x)</span>)</span><br></pre></td></tr></table></figure><ul><li>这个知识点主要要明确的就是，是“x=y”，而不是“x=$(y)”,如果没有$,关于y的值不会自动解开来赋值给x的</li></ul></li><li><p>使用多个变量来组成一个变量的名字，然后再取其值</p>  <figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">first_second = Hello</span><br><span class="line">a = first</span><br><span class="line">b = second</span><br><span class="line">all = $($a_$b)</span><br></pre></td></tr></table></figure><blockquote><p>这个例子中，如果 $(a1) 的值是“a”的话，那么， $(sources) 的值就是“a.c b.c c.c”；如果 $(a1) 的值是“1”，那么 $(sources) 的值是“1.c 2.c 3.c”。<br>所以配合条件句使用特别好</p></blockquote></li><li><p>也可以放在左值中</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$(dir)</span>_sources := <span class="variable">$(<span class="built_in">wildcard</span> <span class="variable">$(dir)</span>/*.c)</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="多行变量"><a href="#多行变量" class="headerlink" title="多行变量"></a>多行变量</h3><ul><li><p>利用原理：因为命令需要以[Tab]键开头，所以如果你用define定义的命令变量中没有以 Tab 键开头，那么make 就不会把其认为是命令。</p></li><li><p>格式</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">define</span> two-lines</span><br><span class="line">echo foo</span><br><span class="line">echo <span class="variable">$(bar)</span></span><br><span class="line"><span class="keyword">endef</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="overridd"><a href="#overridd" class="headerlink" title="overridd"></a>overridd</h3><p>如果有变量是通常make的命令行参数设置的，那么Makefile中对这个变量的赋值会被忽略</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 覆盖外部命令行的定义</span></span><br><span class="line"><span class="keyword">override</span> &lt;variable&gt;; = &lt;value&gt;;</span><br><span class="line"><span class="keyword">override</span> &lt;variable&gt;; := &lt;value&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 追加覆盖方式</span></span><br><span class="line"><span class="keyword">override</span> &lt;variable&gt;; += &lt;more text&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 多行变量的覆盖</span></span><br><span class="line"><span class="keyword">override</span> <span class="keyword">define</span> foo</span><br><span class="line">bar</span><br><span class="line"><span class="keyword">endef</span></span><br></pre></td></tr></table></figure><h2 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h2><ul><li>优先考虑文件中的，但是如果有make -e的参数，就优先考虑e(nvironment)的变量</li></ul><h2 id="目标变量-Target-specific-Variable"><a href="#目标变量-Target-specific-Variable" class="headerlink" title="目标变量 Target-specific Variable"></a>目标变量 Target-specific Variable</h2><ul><li><p>变量分类</p><ul><li>全局变量<br>  整个文件，我们都可以访问这些变量</li><li>自动化变量<br>  如 $&lt; 等这种类量的自动化变量就属于“规则型变量”，这种变量的值依赖于规则的目标和依赖目标的定义</li><li>目标变量<br>  可以和“全局变量”同名，因为它的作用范围只在这条规则以及连带规则中，所以其值也只在作用范围内有效。而不会影响规则链以外的全局变量的值</li></ul></li><li><p>这个特性非常的有用，当我们设置了这样一个变量，这个变量会作用到由这个目标所引发的所有的规则中去。如：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">prog : CFLAGS = -g</span><br><span class="line">prog : prog.o foo.o bar.o</span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> prog.o foo.o bar.o</span><br><span class="line"></span><br><span class="line">prog.o : prog.c</span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> prog.c</span><br><span class="line"></span><br><span class="line">foo.o : foo.c</span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> foo.c</span><br><span class="line"></span><br><span class="line">bar.o : bar.c</span><br><span class="line">    <span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> bar.c</span><br></pre></td></tr></table></figure><p>在这个示例中，不管全局的 $(CFLAGS) 的值是什么，在prog目标，以及其所引发的所有规则中（prog.o foo.o bar.o的规则）， $(CFLAGS) 的值都是 -g</p></li><li><p>语法</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;target ...&gt; : &lt;variable-assignment&gt;;</span><br><span class="line">&lt;target ...&gt; : overide &lt;variable-assignment&gt;</span><br></pre></td></tr></table></figure><p><variable-assignment>;可以是前面讲过的各种赋值表达式，如 = 、 := 、 += <code>或是</code>?= 。第二个语法是针对于make命令行带入的变量，或是系统环境变量。</p></li></ul><h2 id="模式变量-Pattern-specific-Variable"><a href="#模式变量-Pattern-specific-Variable" class="headerlink" title="模式变量 Pattern-specific Variable"></a>模式变量 Pattern-specific Variable</h2><ul><li>其实没有很懂 如何 定义到<strong>模式</strong>上，还要<span class="exturl" data-url="aHR0cHM6Ly9zZWlzbWFuLmdpdGh1Yi5pby9ob3ctdG8td3JpdGUtbWFrZWZpbGUvdmFyaWFibGVzLmh0bWw=">回来<i class="fa fa-external-link-alt"></i></span>再看下</li></ul><h2 id="自动化变量"><a href="#自动化变量" class="headerlink" title="自动化变量"></a>自动化变量</h2><h2 id="特殊变量"><a href="#特殊变量" class="headerlink" title="特殊变量"></a>特殊变量</h2><ul><li>${MAKELEVEL}</li><li>${MAKE}<ul><li>代替make命令本身，在递归调用子文件中的makefile的时候，不能出现make本身(否则会陷入无穷的递归)，应该使用${MAKE}</li><li><span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMjIwNjEyOC9ob3ctdG8tY2FsbC1tYWtlZmlsZS1mcm9tLWFub3RoZXItbWFrZWZpbGU=">refer<i class="fa fa-external-link-alt"></i></span></li><li>经常和-C参数一起使用，代表进入一个目录后使用make命令<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">subsystem:</span></span><br><span class="line">    cd subdir &amp;&amp; <span class="variable">$(MAKE)</span> <span class="comment"># 注意，这两行命令不能分开写</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#  与上面的作用是一致的</span></span><br><span class="line"><span class="section">subsystem:</span></span><br><span class="line">    <span class="variable">$(MAKE)</span> -C subdir</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更进一步，我想要执行特定的命令(比如clean)</span></span><br><span class="line"><span class="section">subsystem:</span></span><br><span class="line">    <span class="variable">$(MAKE)</span> -C subdir clean</span><br></pre></td></tr></table></figure></li></ul></li></ul><h2 id="关于各种赋值符号的小总结"><a href="#关于各种赋值符号的小总结" class="headerlink" title="关于各种赋值符号的小总结"></a>关于各种赋值符号的小总结</h2><ul><li>=</li><li>:=</li><li>?=</li><li>+=</li></ul><h1 id="隐含规则"><a href="#隐含规则" class="headerlink" title="隐含规则"></a>隐含规则</h1><h2 id="basis-1"><a href="#basis-1" class="headerlink" title="basis"></a>basis</h2><ul><li>如果没有写.o文件的生成规则，默认就会调用如下规则:把 .o 的目标的依赖文件置成 .c ，并使用C的编译命令 cc –c $(CFLAGS)  foo.c 来生成 foo.o 的目标</li><li>隐含规则可能优先于别的规则被使用，因为隐含规则也有分优先级</li><li>模式的隐含规则，只不过是规则中要有 % 罢了</li></ul><h2 id="自动化变量-1"><a href="#自动化变量-1" class="headerlink" title="自动化变量"></a>自动化变量</h2><ul><li><p>扩展时会一个个文件取出</p><ul><li><p>$@</p></li><li><p>$%</p></li><li><p>$&lt;</p></li><li><p>$*</p><blockquote><p>$* 指代匹配符 % 匹配的部分， 比如% 匹配 f1.txt 中的f1 ，$* 就表示 f1。</p><p>这里陈皓的一起来写makefile里面写错了</p></blockquote></li></ul></li><li><p>返回文件列表</p><ul><li><p>$?<br>  <strong>比较有用</strong></p><blockquote><p>所有比目标新的依赖目标的集合。以空格分隔。</p></blockquote></li><li><p>$^</p><blockquote><p>所有的依赖目标的集合。以空格分隔。如果在依赖目标中有多个重复的，那么这个变量会去除重复的依赖目标，只保留一份。</p></blockquote></li><li><p>$+</p><blockquote><p>所有的依赖目标的集合。以空格分隔。如果在依赖目标中有多个重复的，那么这个变量会去除重复的依赖目标，只保留一份。</p></blockquote></li></ul></li></ul><h2 id="本章节尾部tl-dr"><a href="#本章节尾部tl-dr" class="headerlink" title="本章节尾部tl;dr"></a><span class="exturl" data-url="aHR0cHM6Ly9zZWlzbWFuLmdpdGh1Yi5pby9ob3ctdG8td3JpdGUtbWFrZWZpbGUvaW1wbGljaXRfcnVsZXMuaHRtbCM=">本章节尾部<i class="fa fa-external-link-alt"></i></span>tl;dr</h2><h1 id="question"><a href="#question" class="headerlink" title="question"></a>question</h1><ul><li><p><input checked="" disabled="" type="checkbox">  手写makefile不是很麻烦？没有自动的么？like cmake</p><blockquote><p>autotools（常见的./configure文件就是autotools生成的）和 cmake （cmakelist） 都是用于自动生成makefile的</p></blockquote></li><li><p><input checked="" disabled="" type="checkbox">  := 和 = 的区别</p><blockquote><p>后者可以使用未定义(但是后文定义了的)变量，但是前者不可以（所以更安全）</p></blockquote></li><li><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vd2FycmVuLXdvbmcvcC8zOTc5MjcwLmh0bWw=">Makefile中*和%的区别<i class="fa fa-external-link-alt"></i></span></p></li><li><p><input checked="" disabled="" type="checkbox">  CPPFLAGS 和 CXXFLAGS 的区别</p><blockquote><p>前者是C预处理器的参数（PP代表preprocessing），后者是C++的语言编译器</p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      makefile的总结和梳理
    
    </summary>
    
    
      <category term="Summary" scheme="http://yoursite.com/categories/Summary/"/>
    
    
      <category term="Compilation and Link" scheme="http://yoursite.com/tags/Compilation-and-Link/"/>
    
  </entry>
  
  <entry>
    <title>Dynamic TCP Initial Windows and Congestion Control Schemes through Reinforcement Learning(JSAC&#39;19)</title>
    <link href="http://yoursite.com/2020/09/09/PaperReading/TCP-RL/"/>
    <id>http://yoursite.com/2020/09/09/PaperReading/TCP-RL/</id>
    <published>2020-09-09T12:00:00.000Z</published>
    <updated>2020-10-21T19:24:32.693Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><ul><li>不需要<strong>客户端</strong>或者中间件做任何改动 [ 惊了 ]</li></ul><blockquote><p>为了解决挑战一，TCP-RL 修改了前端服务器的 Linux 内核代码和 Web Server 应用 Nginx的代码，使得服务器能够测量并且实时输出每条用户请求的 TCP 流信息(比如网络传输延迟、丢包率、RTT 等)。整个过程在服务器端完 成，不需要客户端或者中间件做任何改动。该数据采集和测量的工具不仅仅可以用于初始窗口的调整，也可用于 Web 服务的网络性能指标管理、监控、 故障诊断。</p></blockquote><ul><li>对于问题的建模做的很好，而且作为了一个challenge</li></ul><p>hesy:The long flow switch like this, the cold start process should not be ignored–”Use SmartIW</p><h1 id="inspiration-of-hesy"><a href="#inspiration-of-hesy" class="headerlink" title="inspiration of hesy"></a>inspiration of hesy</h1><ul><li><p>要会用这个词: <strong>data-driven</strong> 代替 ML-based 或者RL-based。高大上！</p></li><li><p>contribution绝对不能写自己是首先用DRL做这个的，因为还有些水会也是做这个的，所以我们也要credit他们并且讲清楚区别。</p></li><li><p>写作的时候要注意层次感，不能一上来就说这个feature适合用RL做，应该先给出一个也比较适合但是naive的solution，再说RL可以解决这个naive的defects</p></li><li><p>目标函数或者奖励函数的形式  需要找人背书，不能自己造一个</p><ul><li>目标函数没有想好要不要让清空队列，因为延迟梯度也能包含这个目标。（或许可以做一个实验来证明这两个的相关性，看下Timely怎么做ECN和延迟的相关性的，记得这两个并不是很大程度上的相关鸭）</li></ul></li><li><p>实验细节要好好看下</p></li></ul>]]></content>
    
    <summary type="html">
    
      RL+CC
    
    </summary>
    
    
      <category term="PaperReading" scheme="http://yoursite.com/categories/PaperReading/"/>
    
    
      <category term="Network" scheme="http://yoursite.com/tags/Network/"/>
    
      <category term="Reinforcement Learning" scheme="http://yoursite.com/tags/Reinforcement-Learning/"/>
    
      <category term="Congestion Control" scheme="http://yoursite.com/tags/Congestion-Control/"/>
    
  </entry>
  
  <entry>
    <title>DeePCCI(SIGCOMM&#39;19)</title>
    <link href="http://yoursite.com/2020/08/09/PaperReading/IOT/"/>
    <id>http://yoursite.com/2020/08/09/PaperReading/IOT/</id>
    <published>2020-08-09T12:00:00.000Z</published>
    <updated>2020-10-21T19:24:32.693Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css">]]></content>
    
    <summary type="html">
    
      RL+CC
    
    </summary>
    
    
      <category term="PaperReading" scheme="http://yoursite.com/categories/PaperReading/"/>
    
    
      <category term="Network" scheme="http://yoursite.com/tags/Network/"/>
    
      <category term="Reinforcement Learning" scheme="http://yoursite.com/tags/Reinforcement-Learning/"/>
    
      <category term="Congestion Control" scheme="http://yoursite.com/tags/Congestion-Control/"/>
    
  </entry>
  
  <entry>
    <title>Research on Transport Control and Flow Scheduling in Low-latency Datacenter Networks</title>
    <link href="http://yoursite.com/2020/08/08/PaperReading/Research-on-Transport-Control-and-Flow-Scheduling-in-Low-latency-Datacenter-Networks/"/>
    <id>http://yoursite.com/2020/08/08/PaperReading/Research-on-Transport-Control-and-Flow-Scheduling-in-Low-latency-Datacenter-Networks/</id>
    <published>2020-08-08T21:39:43.000Z</published>
    <updated>2020-10-21T19:24:32.693Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="第一章-引言"><a href="#第一章-引言" class="headerlink" title="第一章 引言"></a>第一章 引言</h1><ul><li>数据中心应用类型</li><li>数据中心流量特性</li><li>仍存在的问题</li></ul><p><img src="https://images.weserv.nl/?url=https://gitee.com/HesyH/Image-Hosting/raw/master/image4typora/202008/08/214444-685710.png" alt="image-20200808214442717"></p><p>说实话感觉这里讲的不是很清楚，回头再来仔细梳理下把。</p><h1 id="第二章-背景和相关综述"><a href="#第二章-背景和相关综述" class="headerlink" title="第二章 背景和相关综述"></a>第二章 背景和相关综述</h1><ul><li>传统TCP及研究进展<ul><li>调整AIMD参数 –》good idea ==但是还是那个问题，为什么要搞pacing，而放弃窗口==</li><li>==incast 难道是数据中心特有的问题?== 其实只要BDP足够小就可以把？RTT不够小，但是我bandwidth够小总可以吧？TCP incast不就是拥塞么?<ul><li>我感觉只要是低延迟链路，就会有这种情况 （一旦有超时发生， 网络中会出现长时间的链路闲置状态）</li><li>如果要在数据中心做，得考虑放弃短流的调度，只调度长流？看看iroko怎么做的？</li></ul></li><li>DCTCP是解决TCP incast的？？</li></ul></li></ul><ul><li><p>TCP incast</p><ul><li><p>以前的解决方案</p><blockquote><p>第一类的主要方法是修改TCP配置参数，将RTO设置为微秒级 别，从而减小超时重传所需的等待时间; 第二类为修改TCP的拥塞控制算法，提高 缓存利用率，进而避免丢包；第三类是通过修改QCN算法来提高协议公平性；第 四类摒弃 TCP 方案采用 UDP 方案彻底避免超时重传的问题。</p></blockquote></li></ul></li><li><p>多种流量共存</p><ul><li><p>长流(重视高吞吐) &amp; 短流(重视低延迟) –》 目标不同</p></li><li><p>相互作用：长流容易造成短流的饥饿</p></li><li><p>还有部分应用存在截止时间需求 ，whose 主要性能指标是截止时间错过率</p></li><li><p>应对措施</p><blockquote><p>非截止时间流调度机制和传输协议研究，截止时间流调度机制 和传输协议研究和混合流调度机制和传输协议研</p></blockquote></li></ul></li><li><p>任务调度</p></li></ul><p><img src="https://images.weserv.nl/?url=https://gitee.com/HesyH/Image-Hosting/raw/master/image4typora/202008/09/154827-641523.png" alt="image-20200809154826511"></p><h1 id="第三章-支持选择性反馈的编码传输协议研究研究"><a href="#第三章-支持选择性反馈的编码传输协议研究研究" class="headerlink" title="第三章 支持选择性反馈的编码传输协议研究研究"></a>第三章 支持选择性反馈的编码传输协议研究研究</h1><ul><li>关于发送速率，on friendliness ，需要做的是：找论文背书，基于别人的公式进行建模</li></ul><h1 id="第四章-数据中心网络的混合流调度机制SMF"><a href="#第四章-数据中心网络的混合流调度机制SMF" class="headerlink" title="第四章 数据中心网络的混合流调度机制SMF"></a>第四章 数据中心网络的混合流调度机制SMF</h1><blockquote><p>这一部分讲的比较详细</p></blockquote><h2 id="miscelleneous"><a href="#miscelleneous" class="headerlink" title="miscelleneous"></a>miscelleneous</h2><ul><li>如何判断截止时间流还有非截止时间流本身也是个很大的问题啊！</li><li>传统解决方案中，基于速率的控制协议（RCP）到底是什么呢？Karuna采用的MCP又是什么呢?</li></ul><h2 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路"></a>算法思路</h2><ul><li><p>SMF</p><ul><li>对于非截止事件流，采用SJF</li><li>对于截止事件流，采用MLFQ</li><li>是满足多重目标的分布式拥塞控制协议，旨在调度混合流以改善流完成率和流完成时间</li><li>也对初始窗口大小做了改进，where也很重要。裴丹的，实际上是根据具体的业务进行改进了的。看看SMF采取了哪些feature，怎么做的，或许也是一个点？</li></ul></li><li><p>NP-hard问题证明</p><ul><li>截止时间流</li><li>非截止时间流（ 感觉讲得也很粗糙</li><li>所以使用启发式</li></ul></li><li><p>对于不能在截止时间前完成的流，<strong>“早丢弃”</strong>方式提前丢弃以节省网络带宽</p><ul><li>==自己的机制里面如果太简单，也可以加一些“早丢弃”等手工的规则==</li></ul></li><li><p>考察指标</p></li></ul><img src="C:\Users\hesy\AppData\Roaming\Typora\typora-user-images\image-20200809171054378.png" alt="image-20200809171054378" style="zoom: 80%;" /><h1 id="第五章-任务级别的截止时间感知流调度机制研究TAPS"><a href="#第五章-任务级别的截止时间感知流调度机制研究TAPS" class="headerlink" title="第五章 任务级别的截止时间感知流调度机制研究TAPS"></a>第五章 任务级别的截止时间感知流调度机制研究TAPS</h1><h2 id="重要性"><a href="#重要性" class="headerlink" title="重要性"></a>重要性</h2><ul><li><p>如果某任务没有在截止事件前完成，那么该任务已经成功传输完成的所有数据都是无用数据。非常不幸的是，数据中心网络中采用的大部分传输协议，都是基于竞争的传输协议，如 TCP，RCP[35]，ICTCP[10]，DCTCP[2]，采用平均分配带宽的原则为网络中互相竞争的每条流分配链路以及可用带宽。这些方案固然可以有效将数据流从源端传输到目的端，但是他们忽略了数据流或是任务的截止时间，同时也没有意识到不同流之间的区别，无法做到最小化网络流完成时间。</p></li><li><p>统计数据表明，对于 web 应用，每个任务至少包括 88 条流[2]，对于 MapReduce 搜索工作每个任务包含 30 到 50000 条流[6]，对于 Cosmos 每个任务约包含 30 到 70 条流[97]。这些统计数据表明在数据中心内，很多应用对于每个任务会产生相应的多条数据流来完成，因此任务才是处理的单位。</p></li></ul><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>使用SDN</p>]]></content>
    
    <summary type="html">
    
      data center TCP congestion control ， 做了三方面的工作
    
    </summary>
    
    
      <category term="PaperReading" scheme="http://yoursite.com/categories/PaperReading/"/>
    
    
      <category term="Network" scheme="http://yoursite.com/tags/Network/"/>
    
      <category term="Congestion Control" scheme="http://yoursite.com/tags/Congestion-Control/"/>
    
  </entry>
  
  <entry>
    <title>python总结</title>
    <link href="http://yoursite.com/2020/08/08/Summary/python/"/>
    <id>http://yoursite.com/2020/08/08/Summary/python/</id>
    <published>2020-08-08T17:35:17.000Z</published>
    <updated>2020-10-21T19:24:32.693Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="深浅拷贝"><a href="#深浅拷贝" class="headerlink" title="深浅拷贝"></a>深浅拷贝</h1><ul><li>说千道万，不如<span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMWNjNDExaDdoZD9mcm9tPXNlYXJjaCZzZWlkPTE3OTE4NDE2ODkwNDkxMDIzMzY=">画图实在<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vbG9sZWluYS9wLzUyNzY5MTguaHRtbA==">函数传参，传的是引用<i class="fa fa-external-link-alt"></i></span><blockquote><p>Python参数传递采用的肯定是“传对象引用”的方式。这种方式相当于传值和传引用的一种综合。如果函数收到的是一个<strong>可变对象（比如字典或者列表）</strong>的引用，就能修改对象的原始值－－相当于通过“传引用”来传递对象。如果函数收到的是一个<strong>不可变对象（比如int、str或者tuple</strong>）的引用，就不能直接修改原始对象－－相当于通过“传值’来传递对象。 </p><blockquote><p> 注意，tuple本身不可变，但是tuple里面的元素可变</p></blockquote></blockquote></li></ul><h1 id="闭包-amp-nonlocal"><a href="#闭包-amp-nonlocal" class="headerlink" title="闭包 &amp; nonlocal"></a>闭包 &amp; nonlocal</h1><ul><li><a href="nonlocal">nonlocal</a></li><li><span class="exturl" data-url="aHR0cHM6Ly9zZWdtZW50ZmF1bHQuY29tL2EvMTE5MDAwMDAwNDQ2MTQwNA==">闭包<i class="fa fa-external-link-alt"></i></span><ul><li>其中几个作用：节省开销，将函数与某个参数绑定</li><li>装饰器就是一种闭包</li></ul></li></ul><h1 id="subprocess"><a href="#subprocess" class="headerlink" title="subprocess"></a>subprocess</h1><p>可以参考<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2E0NjQwNTcyMTYvYXJ0aWNsZS9kZXRhaWxzLzQ3MzU1MjE5">这个<i class="fa fa-external-link-alt"></i></span></p><h1 id="joyful-pandas"><a href="#joyful-pandas" class="headerlink" title="joyful pandas"></a>joyful pandas</h1><blockquote><p>pandas的一些少见的注意事项，具体代码和例子来源于datawhale的<span class="exturl" data-url="aHR0cHM6Ly9uYnZpZXdlci5qdXB5dGVyLm9yZy9naXRodWIvR1lISEFIQS9Kb3lmdWwtUGFuZGFzL3RyZWUvbWFzdGVyLw==">Joyful-Pandas系列<i class="fa fa-external-link-alt"></i></span></p></blockquote><h3 id="1-基础"><a href="#1-基础" class="headerlink" title="1.基础"></a>1.基础</h3><ul><li>df.value_count()</li><li>df.unique()</li><li>df.nunique()</li><li>df.describe()的一些用法<ul><li>可以自行选择分位数 df.describe(percentiles=[.05, .25, .75, .95])</li><li>非数值型也可以用describe函数</li></ul></li></ul><p><img src="https://images.weserv.nl/?url=https://gitee.com/HesyH/Image-Hosting/raw/master/image4typora/202008/26/112845-885917.png" alt="image-20200826112844748"></p><ul><li>还有一些练习题，也可以做下</li></ul><h3 id="2-索引"><a href="#2-索引" class="headerlink" title="2. 索引"></a>2. 索引</h3><ul><li><p>函数式索引 &amp; 布尔索引</p></li><li><p><strong>loc</strong>可以接收整数或整数列表或布尔列表以及Series，而<strong>iloc</strong>中接收的参数只能为整数或整数列表或布尔列表，不能使用布尔Series，如果要用就必须使用.values()把dataframe里面的列表拿出来</p></li><li><p>索引不要用浮点数，否则在切片索引的时候，[2: ]就表示的不是索引的下标从第二个开始了，而是用比大小的方式去看哪些行的索引值比2大，都拿出来</p></li><li><p>[]的索引方式中，比较灵活。有几种方式：</p><ul><li><p>索引index：</p><ol><li><p>data[3:5] 数字的话，就是索引行的绝对位置，就算index也是数字，也不要混淆啊！</p><ul><li><p>这个和data.iloc[3:5]效果是一样的(Series和DataFrame都适用)</p><blockquote><p>tip: loc和iloc其实都是二维的，如果只写了一个维度，就是指的index</p></blockquote></li><li><p>对于Series来说，这个和data[data.index[3:5]]效果是一样的（但是DataFrame就会报错的）</p></li></ul></li><li><p>如果index也是数字，想要索引对应于某个数值的index怎么办？(比如索引index为33的那一行)<br> data[data.index.get_loc(33)]</p></li></ol></li><li><p>索引column：<br>  如果index是str类型，data[“label”]默认也是索引column（最标准的写法还是loc[:,”label”]）</p><blockquote><p>注意，我个人测试的时候loc对于Series也是不会报错的，但是我还是不建议。因为容易混肴，Series没必要用loc，具体的含义我也搞不清楚</p></blockquote></li></ul></li><li><p>[快速标量索引]:当只需要取一个元素时，at和iat方法能够提供更快的实现</p><blockquote><p>看到区间索引，其实目前觉得差不多了。没必要再学更多了</p></blockquote></li></ul><h1 id="画图"><a href="#画图" class="headerlink" title="画图"></a>画图</h1><blockquote><p>所有高级的api，包括seaborns在内，都是基于最基本的matplotlib开始的，那么一定都得先搞清matplotlib的基本概念（ax和fig等）</p></blockquote><img src="https://img-blog.csdnimg.cn/20200311202147484.png" alt="在这里插入图片描述" style="zoom:67%;" /><ul><li>每一次subplot动作都是独立的</li></ul><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">fig = plt.figure(num=<span class="string">&#x27;panel&#x27;</span>, figsize=(<span class="number">8</span>,<span class="number">4</span>),facecolor=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line"><span class="comment"># 绘制两个不同大小的区域</span></span><br><span class="line">plt.subplot(<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>) <span class="comment"># 划分1行3列，第1个子区域</span></span><br><span class="line">plt.subplot(<span class="number">1</span>,<span class="number">2</span>,<span class="number">2</span>) <span class="comment"># 划分1行2列，第2个子区域</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>其实把每一次 <code>subplot</code> 动作看作是独立的就行了，第一次将整个画板划分为1行3列完全不影响第二次划分为1行2列，它们仅影响当前划分后子图的大小。</p><img src="https://img-blog.csdnimg.cn/20190930150818814.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzMxMzQ3ODY5,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" style="zoom:67%;" /></blockquote><ul><li><p>添加子图</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">######## 使用figure + addsubplot ########</span></span><br><span class="line">fig = plt.figure()</span><br><span class="line">ax1 = fig.add_subplot(<span class="number">221</span>)</span><br><span class="line">ax2 = fig.add_subplot(<span class="number">222</span>)</span><br><span class="line">ax3 = fig.add_subplot(<span class="number">212</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">######## 使用figure + subplot ########</span></span><br><span class="line">fig = plt.figure(num=<span class="string">&#x27;panel&#x27;</span>, figsize=(<span class="number">8</span>,<span class="number">4</span>),facecolor=<span class="string">&#x27;gray&#x27;</span>)</span><br><span class="line"><span class="comment"># 划分三个小区域，绘制出第一个和第三个区域</span></span><br><span class="line">plt.subplot(<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>)  <span class="comment"># 划分1行3列，第1个子区域  </span></span><br><span class="line">plt.subplot(<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>)  <span class="comment"># 划分1行3列，第3个子区域</span></span><br><span class="line">plt.show()</span><br><span class="line">true<span class="comment"># 注意，这里是plt.subplot而不是fig.add_subplot，which让我感到奇怪，但是先记住吧</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">######## 使用subplots,which是最常用的 ########</span></span><br><span class="line">fig, axes = plt.subplots(<span class="number">1</span>, <span class="number">2</span>, figsize=(<span class="number">6</span>,<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># plot data</span></span><br><span class="line">axes[<span class="number">0</span>].plot(A,B)</span><br><span class="line">axes[<span class="number">1</span>].scatter(A,C)</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>用 <code>subplots</code> 创建一个画板，同时也创建了一个绘图子区域 <code>axes</code>。画板赋值给了 <code>fig</code>，绘画子区域赋值给了 <code>ax</code>。这样一来，所有 <code>fig.***</code> 都是对整个画板进行操作，所有 <code>ax.***</code> 都是对这个 Aexs 子区域进行操作。</p></blockquote></li><li><p><strong>fig.xx 如果用于处理ax内部的属性，比如轴的刻度范围之类的，其实都是对ax.xx的api的封装</strong>，所以掌握ax.xx才是王道 和 最正确的方式</p></li></ul>]]></content>
    
    <summary type="html">
    
      关于python的总结
    
    </summary>
    
    
      <category term="Summary" scheme="http://yoursite.com/categories/Summary/"/>
    
    
      <category term="Language" scheme="http://yoursite.com/tags/Language/"/>
    
  </entry>
  
  <entry>
    <title>Network常识记录</title>
    <link href="http://yoursite.com/2020/08/07/Summary/CC%E5%B8%B8%E8%AF%86%E8%AE%B0%E5%BD%95/"/>
    <id>http://yoursite.com/2020/08/07/Summary/CC%E5%B8%B8%E8%AF%86%E8%AE%B0%E5%BD%95/</id>
    <published>2020-08-07T22:35:17.000Z</published>
    <updated>2020-10-21T19:24:32.693Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="一些默认设置"><a href="#一些默认设置" class="headerlink" title="一些默认设置"></a>一些默认设置</h1><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuc3ByaW50Lm5ldC9zbGFfcGVyZm9ybWFuY2UucGhwP25ldHdvcms9c2w=">Sprint.net中统计的网络性能参数<i class="fa fa-external-link-alt"></i></span> </li><li>rtt普通情况下也就0.1s【CUBIC论文中写的】(数据中心中就是微秒级别)<ul><li>BBR论文中表示，由于buffer是BDP的几个数量级，所以rtt从毫秒级别变成了秒级</li></ul></li><li>DC中的带宽应该是10Gbps</li></ul><h1 id="How-can-we-be-aware-of-congestion"><a href="#How-can-we-be-aware-of-congestion" class="headerlink" title="How can we be aware of congestion"></a>How can we be aware of congestion</h1><ul><li><p>the internet is a <strong><code>decentralized</code></strong> system, and as a result of that, doesn’t have any central coordinator telling senders to slow down if link queues downstream of some sender are filling up.</p></li><li><p>There are two main indicators: <strong><code>packet loss</code></strong> and increased  <strong><code>round trip times</code></strong>  for packets. </p><ul><li><p>If a sender notices packet loss, it’s a pretty good indicator that congestion is occuring. </p></li><li><p>Another consequence of queues filling up though is that if packets are spending more time in a queue before making it onto the link, the round trip time, which measures the time from when the sender sends a segment out to the time that it receives an acknowledgement, will increase.</p><blockquote><p>summary：可以通过 <strong>packet loss</strong> 和 <strong>RTT</strong> 这两个现象来观察是否有congestion</p></blockquote></li></ul></li></ul><h1 id="概念解释-辨析"><a href="#概念解释-辨析" class="headerlink" title="概念解释/辨析"></a>概念解释/辨析</h1><h2 id="sending-rate-amp-delivery-rate"><a href="#sending-rate-amp-delivery-rate" class="headerlink" title="sending rate &amp; delivery rate"></a>sending rate &amp; delivery rate</h2><ul><li>sending rate就是发送速率</li><li>delivery rate强调接收方收到的包的速率（你发出去但是人家不一定能收到不是</li></ul><h2 id="pacing"><a href="#pacing" class="headerlink" title="pacing"></a>pacing</h2><ul><li>TCP的流控机制，基本上是有两种的，专业一点的说法分别叫做pure rate control和windows-based这两种<ul><li>pure rate control <ul><li>告诉你sender一个发送速率(bottleneck bandwidth)，sender的发送速率不超过这个确定值。</li></ul></li><li>window-based control<ul><li>这个就是常见的TCP 滑动窗口的协议，就是有一个ack确认后我才能发送下面的。</li></ul></li><li>pacing结合了这两种<ul><li>uses the tcp window to determine how much to send but uses rates instead of acknowledgments to determine when to send.</li><li>为什么要这样，因为标准TCP的发包是back-to-back的,TCP的这种clumped方式会引发高延迟以及burst traffic下的丢包大大增加，同时还有ACK Compression，Multiplexing等各种问题都会导致性能受损，所以有人突出了一个机制，我们能不能不让包堆在一起发，在一个窗口里流出间隔，那我们的排队队长就会下降的。</li><li>pacing可以看作TCP的一个变体，是结合了上面的两个流控方式，他使用tcp window决定发多少,用bottleneck bandwidth决定什么时候发，它定义了一个发包的间隔</li></ul></li><li>paing需要优化嘛？需要。 更多的可以看这个<span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8zMDc0MTA3Mw==">专栏<i class="fa fa-external-link-alt"></i></span>搜集的paper  </li></ul></li></ul><h2 id="ACK-compression"><a href="#ACK-compression" class="headerlink" title="ACK compression"></a>ACK compression</h2><ul><li>由于中间链路的缓存以及和其他TCP连接一起共享缓存等原因，可能会导致ACK报文成堆到达发送端。这种场景我们就称呼为ACK压缩。</li><li>i.e. 一个TCP发送者的 自计时取决于到来的，由接收机按照相同时间间隔生成的ACK。如果这些的ACK通过网络过境期间存在一些开销在队列中，但是，它们的间隔可能会改变。当ACK的到达间距小于它们发送的间距，发送者可能会被误导，发送比网络可以接受的更多的数据，这可能导致堵塞和效率损失。</li><li>于ACK compression场景，reno拥塞控制就是逐个处理每个ACK报文，这样就会导致拥塞窗口突然增大，发送端突然发出大量的TCP报文，这种突然发出大量数据的行为我们称呼为burst，影响网络平稳。另外一方面ACK compression还会影响RTT估计，之前我们介绍过有些拥塞控制算法基于时延来来估计网络拥塞情况，因此 ACK compresion还会影响这类基于时延的拥塞控制算法的性能。</li></ul><h2 id="数据平面-amp-控制平面"><a href="#数据平面-amp-控制平面" class="headerlink" title="数据平面&amp;控制平面"></a>数据平面&amp;控制平面</h2><p>除了控制平面(Control Plane)和数据平面(Data Plane)还有管理平面(Management Plane)。数据平面又叫转发平面(Forwarding Plane),通过查看收到流量的目的地址，按照转发表(forwarding table)来处理流量的去向。可能转发流量去一个出接口，可能丢弃流量，或者送去控制平面做进一步处理。控制平面维持数据平面操作所需的必要信息。 这些信息通过协议和算法，收集和计算得来。网络节点间的控制平面能相互交换信息。这些信息被处理之后用于建立不同的表来帮助数据平面的流量操作。除了EIGRP, OSPF, BGP，PIM, HSRP等3层协议以外，CDP,UDLD,LACP,ARP,STP,VLAN等2层协议都属于控制平面。管理平面就是处理配置和监控控制平面。比如CLI, SNMP,XML, Wireshark,NetFlow,SPAN,API,JSON，NETCONF等等都属于管理平面。   </p><h2 id="latency-V-S-delay"><a href="#latency-V-S-delay" class="headerlink" title="latency V.S. delay"></a>latency V.S. delay</h2><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuemhpaHUuY29tL3F1ZXN0aW9uLzU5MzgwNjc0">refer<i class="fa fa-external-link-alt"></i></span></p><ul><li><p><strong>latency</strong></p><p>指的是一个报文进入一台设备以致这台设备所经历的实践。实际上考验的是报文在这台设备上<strong>消耗的时间</strong>。时间越短，这台设备的性能越高。</p></li><li><p><strong>delay</strong></p><p>是指一个操作和另个一个操作之间<strong>停顿的时间</strong>。</p></li></ul><p>所以，latency是不可避免的正常开销，然而delay是额外的开销。</p><h1 id="做CC实验要注意的点"><a href="#做CC实验要注意的点" class="headerlink" title="做CC实验要注意的点"></a>做CC实验要注意的点</h1><ul><li>不仅要测拥塞程度是否改进了</li><li>还要测量收敛速度和fairness to existing congestion control protocols</li></ul><h1 id="数据中心的CC"><a href="#数据中心的CC" class="headerlink" title="数据中心的CC"></a>数据中心的CC</h1><h2 id="learn-from-Lili-Liu’s-paper"><a href="#learn-from-Lili-Liu’s-paper" class="headerlink" title="learn from Lili Liu’s paper"></a>learn from Lili Liu’s paper</h2><ul><li><p>一般<strong>低延迟应用</strong>的流<strong>的 SLA</strong> (Service Level Agreement)要求是 300ms 内完成</p></li><li><p><strong>研究TCP</strong>（而不是一些基于UDP协议）<strong>的重要性</strong> （ 请注意，quic只是实现的一个途径–》用户态 ）</p><ul><li><p>数据中心要求可靠性，目前实现数据中心间的可靠传输的唯一途径是TCP</p><blockquote><p>数据中心间的链路是由 ISP 提供带宽和时延保障的专用链路，但由于路由切换及一 些突发事件，这种专用链路上偶尔也会发生丢包 </p></blockquote><p>根据 ISP 与服务商的SLA，<strong>丢包率一般在 0.5% 到 5% 之间，时延一般不超过 20ms</strong>。</p></li><li><p>研究结果表明数据中心网络中99%的流量都是TCP流量[2]</p><blockquote><p>参考文献[2]是一个2010年的文章</p></blockquote></li><li><p>然而，数据中心网络的传输协议大多数都采用TCP，<strong>并使用平均分配带宽为原则</strong>，将网络资源平均分配。如此做的方案主要有**<u>TCP、RCP[35]、DCTCP和HULL[18]等</u>**</p></li></ul></li><li><p>诸多研究表明<strong>TCP RTO是导致TCP Incast</strong> 的主要原因</p><ul><li>在 TCP 中，默认超时重传计时器 $RTO_min$ 为 200ms，数据中心网络正常 RTT 通常为 200µs</li></ul></li><li><p>数据中心网络传输协议近年来<strong>主要面临的问题</strong>有：</p><ul><li>TCP Incast 问题</li><li>低延迟、高吞吐性能需求</li><li>多任务模式等（对于FCT有要求）</li></ul></li><li><p>最近发表的一个研究([3])表明，网络中由于低效的链路带宽利用率，平均<strong>有 7.25% 的数据流未能在截止时间前完成</strong>。</p></li><li><p>TCP的设计采用平<strong>均分配带宽原则</strong></p></li><li><p><strong>截止时间流和非截止时间流</strong></p><ul><li>尽管数据中心网络中<strong>有截止时间流</strong>所占比率很低，大概是所有流量的 5%。</li><li><strong>非截止时间流</strong>的应用彼此不同。有些应用像 VM 迁移或者数据备份等，在传输开始前就可以得知该流的大小，然而对于一些像数据库存取和 HTTP 分块传输的应用，这些应用在他们传输开始之前不知道流大小或者截止时间相关信息。<ul><li>因此，对于非截止时间流，较短的流完成时间和较高的吞吐率是他们的<strong>主要性能指标</strong>。</li></ul></li></ul></li></ul><h1 id="HULL"><a href="#HULL" class="headerlink" title="HULL"></a>HULL</h1><ul><li>high-performance ultra-low latency</li><li>他从三个层次来进行了设计：<ul><li>Phantom queues: Detecting and signaling congestion<ul><li>这个机制是一种为了创建剩余buffer提出的一种机制，也就是我们常说的bandwidth headroom，通过减少长流带宽来获取更高的短流效率，在端口使用仿真的虚拟队列基于链路利用率而不是利用队列的占有率来设计ECN标记。</li></ul></li><li>DCTCP: Adaptive reaction to ECN</li><li>Packet pacing<ul><li>这个在前面的文章里面也讲了Pacing的实现原理，但是我们也分析过Pacing其实不一定会带来特别好的效果，是有一定条件的，所以这篇文章用了一个硬件pacer，感觉很厉害。但是本质还是按照固定间隔发送封包。</li></ul></li></ul></li></ul><h1 id="some-resources（博客资源-and-so-on）"><a href="#some-resources（博客资源-and-so-on）" class="headerlink" title="some resources（博客资源 and so on）"></a>some resources（博客资源 and so on）</h1><p><span class="exturl" data-url="aHR0cHM6Ly9zcXVpZGFydGguY29tL3JjL3Byb2dyYW1taW5nL25ldHdvcmtpbmcvMjAxOC8wNy8xOC9pbnRyby1jb25nZXN0aW9uLmh0bWw=">squidarth:intro congestion-control<i class="fa fa-external-link-alt"></i></span></p>]]></content>
    
    <summary type="html">
    
      关于拥塞控制的常识/resources
    
    </summary>
    
    
      <category term="Summary" scheme="http://yoursite.com/categories/Summary/"/>
    
    
      <category term="Network" scheme="http://yoursite.com/tags/Network/"/>
    
  </entry>
  
  <entry>
    <title>建站 | Jekyll -》 mkdocs -》 hexo</title>
    <link href="http://yoursite.com/2020/07/30/siteBuilding/"/>
    <id>http://yoursite.com/2020/07/30/siteBuilding/</id>
    <published>2020-07-30T21:50:53.000Z</published>
    <updated>2020-10-21T19:24:32.693Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="Jekyll"><a href="#Jekyll" class="headerlink" title="Jekyll"></a>Jekyll</h1><p>之前是用的jekyll，但是没找到我想要的全局搜索功能，有兴趣的还是可以看下：<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hlc3lfSC9hcnRpY2xlL2RldGFpbHMvMTA0MTg0NzIw">Jekyll建站<i class="fa fa-external-link-alt"></i></span></p><hr><h1 id="mkdocs"><a href="#mkdocs" class="headerlink" title="mkdocs"></a>mkdocs</h1><blockquote><p>其实Jekyll已经省去了很多麻烦了，但是我真的真的很烦每个md开头要写一大段乱七八糟的配置，不方便迁移，所以就转到mkdocs了，虽然模板的页面效果没有Jekyll丰富，但是对懒人还是极其友好的。</p></blockquote><blockquote><p>本来想用mkdocs的，毕竟还是挺省事儿的，文件结构也很清晰，学神点拨下我发现hexo可以全局搜索，跟mkdocs的标题搜索等级比起来，更香了！<br>简单学了下，后续可能考虑用mkdocs做一些项目文档手册，作为子网址吧，做手册挺合适的。</p></blockquote><h2 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h2><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cueG5jb2RpbmcuY29tLzIwMjAvMDMvMDEvdG9vbC9ta2RvY3MuaHRtbA==">蛮详细的，尤其是关于yml配置文件相关的<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d1dG9uZ3RyZWUuZ2l0aHViLmlvL2Rldm9wcy9tYW5hZ2UteW91ci1jbXMtdXNpbmctbWtkb2Nz">配置也很详细，尤其有一些关于mkdocs的冷知识<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9teS5vc2NoaW5hLm5ldC9menhpYW9tYW5nZS9ibG9nLzMwMTA5MjE=">列了一些注意事项，which我也觉得很重要<i class="fa fa-external-link-alt"></i></span></li><li>这个没仔细看，但是感觉很高贵的样子 <span class="exturl" data-url="aHR0cHM6Ly90b3V0aWFvLmlvL3Bvc3RzL3Q5M2E1Yy9wcmV2aWV3">将 Jupyter 自动发布到 GitHub Pages<i class="fa fa-external-link-alt"></i></span></li></ul><h2 id="配置中遇到的问题"><a href="#配置中遇到的问题" class="headerlink" title="配置中遇到的问题"></a>配置中遇到的问题</h2><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0b25lOTE1OS9hcnRpY2xlL2RldGFpbHMvNzkwNzEzMTY=">py37下字符编码遇到的问题<i class="fa fa-external-link-alt"></i></span></p><hr><h1 id="hexo"><a href="#hexo" class="headerlink" title="hexo"></a>hexo</h1><blockquote><p>我的两个config.xml（_config.next.xml是对应next主题的配置）都做了比较详细的注释，大家改起来也会很方便，欢迎在我的基础上修改！（虽然我本来也就是改学神的 :)</p></blockquote><h2 id="ref-1"><a href="#ref-1" class="headerlink" title="ref"></a>ref</h2><ol><li><p>环境配置请参考：<span class="exturl" data-url="aHR0cHM6Ly9scnNjeS5naXRodWIuaW8vMjAxNy8xMS8xMC9VYnVudHUtR2l0aHViLWlvLWNvbmZpZy1IZXhvLw==">linux下使用hexo建站<i class="fa fa-external-link-alt"></i></span>    </p><blockquote><ul><li>安装的时候提示8.x已经deprecated，所以我按照提示安装了12.x</li><li>在服务器上跑<code>npm install -g hexo-cli</code>等命令的时候，会遇到权限不够，根据提示给sudo就行</li></ul></blockquote></li><li><p>推送过程和基本配置网上已经很多了</p><blockquote><ul><li>next主题的仓库已经过期，我用的是学神给的这个：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RoZW1lLW5leHQvaGV4by10aGVtZS1uZXh0">https://github.com/theme-next/hexo-theme-next<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly90ZGluZy50b3AvYXJjaGl2ZXMvNDJjMzhiMTAuaHRtbA==">next主题的基本设置<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC85NDAzODY4OA==">hexo主题进阶设置<i class="fa fa-external-link-alt"></i></span></li></ul></blockquote></li><li><p>其他trivial的可选功能</p><blockquote><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC9kNjhkZTA2N2VhNzQ=">Hexo添加Disqus评论<i class="fa fa-external-link-alt"></i></span></li><li>hexo添加google-analytic功能 （ 不想做了2333累了</li></ul></blockquote></li></ol><h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><p>hexo new ‘文章标题’<br>hexo new draft<br> hexo clean</p><blockquote><p>清除缓存文件 (db.json) 和已生成的静态文件 (public)。在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。</p></blockquote><p>hexo g<br>hexo s<br>hexo d</p><hr><h1 id="mkdown-图床-获取-永久链接-（-香"><a href="#mkdown-图床-获取-永久链接-（-香" class="headerlink" title="mkdown+图床 获取 永久链接 （ 香"></a>mkdown+图床 获取 永久链接 （ 香</h1><p>可以参考<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hlc3lfSC9hcnRpY2xlL2RldGFpbHMvMTA3NjIyMjAy">我之前写的文章：typora+gitee图床<i class="fa fa-external-link-alt"></i></span></p><hr><h1 id="Actions"><a href="#Actions" class="headerlink" title="Actions"></a>Actions</h1><ul><li><input checked="" disabled="" type="checkbox"> <span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81YzQxN2RhNzUxODgyNTI1YzYzODA5Y2Q=">简单入个门<i class="fa fa-external-link-alt"></i></span></li><li><input checked="" disabled="" type="checkbox"> <span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC82ODU0NTczMjE4Nzc5MzgxNzcz">hexo+Actions保姆教程<i class="fa fa-external-link-alt"></i></span></li></ul><p>本来想自己写的，结果学神也用的actions，哈哈作业一抄到底 （ docker确实不太精通啊…  - -||| ）</p><hr><h1 id="miscelleous"><a href="#miscelleous" class="headerlink" title="miscelleous"></a>miscelleous</h1><ul><li><input disabled="" type="checkbox"> 添加多个部署源<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">deploy</span>:</span><br><span class="line">- <span class="attribute">type</span>: git</span><br><span class="line">  <span class="attribute">repo</span>:</span><br><span class="line">- <span class="attribute">type</span>: heroku</span><br><span class="line">  <span class="attribute">repo</span>:</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      github pages建站
    
    </summary>
    
    
      <category term="程序员的自我修养" scheme="http://yoursite.com/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/"/>
    
    
      <category term="tool" scheme="http://yoursite.com/tags/tool/"/>
    
  </entry>
  
  <entry>
    <title>DeePCCI(SIGCOMM&#39;19)</title>
    <link href="http://yoursite.com/2020/02/05/PaperReading/DeePCCI(SIGCOMM&#39;19)/"/>
    <id>http://yoursite.com/2020/02/05/PaperReading/DeePCCI(SIGCOMM&#39;19)/</id>
    <published>2020-02-05T12:00:00.000Z</published>
    <updated>2020-10-21T19:24:32.693Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="introduction"><a href="#introduction" class="headerlink" title="introduction"></a>introduction</h1><blockquote><p>拥塞控制（CC）[12]是当今传输协议的基本组成部分，并强烈影响数据传输的性能。 CC最初建于1980年代以应对早期Internet的拥塞崩溃[17]，但CC仍在发展，并且出现了新的变体，例如BBR [1]或Vivace [3]。</p></blockquote><blockquote><p>CC引入了一个拥塞窗口（cwnd），该窗口限制了飞行中未确认字节的数量。==每种CC算法都定义了在特定算法定义的拥塞信号下，cwnd的变化情况==。给定CC方法的数量及其对性能的影响[9]，因此研究CC的使用方法很重要。例如，如果知道新的CC通常会与哪些其他算法竞争，则为公平起见，更容易对其进行调整。</p></blockquote><h2 id="传统的缺点"><a href="#传统的缺点" class="headerlink" title="传统的缺点"></a>传统的缺点</h2><blockquote><ul><li>但是，用于识别CC变体的现有工作（例如[2、18、24]）不适用于最新的CC和传输协议。==扩展和维护这些方法很复杂，因为它需要详细的领域知识才能知道CC参数化和配置如何影响其行为。== 当CC离开内核并引入用户空间协议（例如QUIC [11]）时，这一点变得尤为重要，这些协议相当容易更改，并且已经可以大规模部署[21]。</li></ul></blockquote><blockquote><ul><li>==此外，许多识别方法都基于fragile assumptions。== 例如，当使用TCP pacing （例如，与RENO [12]或CUBIC [5]结合使用）时，它们将失败。</li><li>*令人担忧的是，我们已知的所有被动方法都基于头部信息is parsable的的假设**。完全加密的传输（例如QUIC实施方案）使这些设计无效，并且如果可能的话，将需要进行重大更改。</li></ul></blockquote><p><strong>因此，目前就推理部署CC提出挑战。</strong></p><h2 id="难点与贡献"><a href="#难点与贡献" class="headerlink" title="难点与贡献"></a>难点与贡献</h2><p>作为应对这些挑战的第一步，本文介绍了DeePCCI，这是一种基于监督的基于深度学习的被动拥塞控制识别方法。<br>==它仅根据流数据包到达时间信息识别CC变体，因此甚至可以在加密的传输头上使用。==<br>此外，它使用深度学习来学习功能-从而避免了手动的，特定于领域的功能设计。<br>因此，与相关方法不同，==DeePCCI除了流分组定时的可用性之外，不做任何假设，== <strong>除了能够收集CC变体的训练流量之外，不需要任何领域知识。</strong><br>我们认为，这种假设和免手动调整方法允许在Internet流量中进行通用且可扩展的CC标识。具体来说，我们介绍DeePCCI的设计，评估及其局限性，并做出以下贡献：</p><p>•我们描述了流量的预处理和用于识别拥塞控制变量的深度学习模型。<br>•我们介绍了如何在测试平台上生成带有标记数据的多种拥塞控制变量模型。</p><p>我们评估了CUBIC，RENO和BBR作为主要拥塞控制变量的测试平台的性能。我们展示了该方法能够在各种情况下识别流量拥塞控制变量，但同时也介绍并讨论了无法识别拥塞控制变量的情况。结构体。第2节讨论了CC识别的最新技术及其缺点。第3节介绍DeePCCI的设计，而第4节介绍我们如何生成训练数据和评估我们的方法。最后，第5节总结了论文并讨论了未来的工作。</p><h1 id="related-work"><a href="#related-work" class="headerlink" title="related work"></a>related work</h1><blockquote><p>各种工作涉及识别CC变体。这些方法主要分为两类：使用被动[2、6、13、18、20]或主动[19、24]测量的识别方法。</p></blockquote><blockquote><p>主动方法可通过主动打开并操纵CC来激发CC反应进行检测。 Padhye和Floyd提出了TBIT [19]，该协议将精心制作的TCP段发送到Web服务器以主动触发拥塞控制。它记录响应丢失的数据包发送了哪些段，因为这种反应在TBIT中所区分的CC变体之间有很大差异。<br><br><br>杨等。目前的CAAI [24]扩展了TBIT的方法。为了估计发送方的cwnd，CAAI人为地延迟了观察所有飞行段的ACK。然后，CAAI导致数据包丢失，并从变化的cwnd中提取特征。这些功能随后用于使用随机森林进行分类。虽然这两种方法都可以实现较高的识别精度，但是由于错误选择的主机，因此依靠主动测量很容易引入测量偏差。<br><br><br>被动方法（与我们一样）不与主机交互，而是依靠流量跟踪来推断使用的流量CC变体，因此，它们允许收集有关实际流量的信息，该信息取决于有利位置而不是主动选择的主机。<br><br><br>Paxson等。和Jaiswal等。使用tcpanaly [20]和tcpflows [13]重建TCP状态机，以比较接收到的数据包和预期数据包。两种方法都需要非常详细的CC甚至实施知识来重建状态机。我们的方法的不同之处在于它不需要详细的CC知识。卡萨格兰德等。 [2]将cwnd中的特征更改用作其方法TCPMoon中的特征。针对这些功能检查了不同的手工规则，以区分CC。对于cwnd估计，作者使用基于TCP时间戳的RTT估计。因此，使用TCPMoon无法识别没有TCP时间戳选项或加密了传输头的流。由于我们的方法仅观察数据包到达的行为，因此不需要任何明文传输协议字段。<br><br><br>Oshio等。 [18]提出了一种基于聚类的方法。他们根据RTT估计值提取cwnd的特征并将其聚类以区分两个竞争的CC变体。我们的方法的不同之处在于，它不仅限于两个相互竞争的变体。哈戈斯等。<br><br><br>[6]使用发送方和接收方之间的未完成字节作为粗略且嘈杂的cwnd估计。使用递归神经网络对该估计值进行细化。精简后的Cwnd的突然减少用作CUBIC，BIC和RENO之间不同的乘法减少因子的估计。尽管此方法使用深度学习是相似的，但它仍然需要手动设计的乘数递减因子，因此只能识别基于损失的CC。我们的方法使用端到端深度学习模型，还识别基于延迟的CC并避免使用手动功能。</p></blockquote><h2 id="active-measurements"><a href="#active-measurements" class="headerlink" title="active measurements"></a>active measurements</h2><ul><li>制造丢包现象（ 通过延迟ack的发送或者是发送crafted packets to senders ）获得终端的变化情况<ul><li>获取了特征数据以后使用随机森林的方法</li></ul></li></ul><h2 id="passive-measurements"><a href="#passive-measurements" class="headerlink" title="passive measurements"></a>passive measurements</h2><ul><li>gather information on real traffic on vantage points ，而不是像active measurements那样观测主动选好的hosts</li><li>rebuild TCP  state machine –》 需要detailed CC domain knowledge and implementation knowledge</li><li>建模去估计Cwnd changes –》 like 使用TCP的时间戳来估计RTT （ 加密了以后就不适用了</li></ul><p><br><br><br></p><h1 id="DeePCCI-design"><a href="#DeePCCI-design" class="headerlink" title="DeePCCI design"></a>DeePCCI design</h1><h2 id="CC-Manifestaion-in-Traffic"><a href="#CC-Manifestaion-in-Traffic" class="headerlink" title="CC Manifestaion in Traffic"></a>CC Manifestaion in Traffic</h2><ul><li>only use <strong>arrival time</strong> of a flow as input<ul><li>unlike Netflow 是什么意思 ？ Netflow没有packet timing嘛</li><li>目的 :associate packets to flow</li></ul></li></ul><h2 id="Architecture"><a href="#Architecture" class="headerlink" title="Architecture"></a>Architecture</h2><p><img src="https://images.weserv.nl/?url=https://img-blog.csdnimg.cn/20190924094304705.png" alt="在这里插入图片描述"></p><h3 id="CNN"><a href="#CNN" class="headerlink" title="CNN"></a>CNN</h3><ul><li>用于特征提取</li><li>改进了VGG net  结合了 residual network</li></ul><h3 id="LSTM"><a href="#LSTM" class="headerlink" title="LSTM"></a>LSTM</h3><ul><li>如果packet的size是固定的，就用VGGNet就够了 ，但是由于我们想看的是length-variant的packet，所以使用LSTM–》有记忆<ul><li>用的是unidirectional network     </li></ul></li></ul><p><br><br><br></p><h1 id="Experimental-setup"><a href="#Experimental-setup" class="headerlink" title="Experimental setup"></a>Experimental setup</h1><h2 id="Mininet-based-Network-Testbed"><a href="#Mininet-based-Network-Testbed" class="headerlink" title="Mininet-based Network Testbed"></a>Mininet-based Network Testbed</h2><ul><li>不同的网络环境<ul><li>TCP sender number</li><li>link latency</li><li>bottleneck link’s BDP</li></ul></li><li>选择了三个variant进行对比 ( RENO, CUBIC ,BBR ) <ul><li>每个发送60s 的fully-loaded TCP stream </li><li>观测者比发送者早2s开启     </li></ul></li></ul><h2 id="Single-Host-Network"><a href="#Single-Host-Network" class="headerlink" title="Single-Host Network"></a>Single-Host Network</h2><ul><li><strong>baseline condition</strong></li><li>哑铃状拓扑</li><li>没有背景流量</li></ul><h2 id="Multi-Host-Network"><a href="#Multi-Host-Network" class="headerlink" title="Multi-Host Network"></a>Multi-Host Network</h2><ul><li>reside on each side of the network</li></ul><h2 id="Cross-Traffic-Network"><a href="#Cross-Traffic-Network" class="headerlink" title="Cross-Traffic Network"></a>Cross-Traffic Network</h2><ul><li>side flow</li><li>main flow</li></ul><h2 id="performance"><a href="#performance" class="headerlink" title="performance"></a>performance</h2><h3 id="identifacation-by-Delay-and-Bandwidth"><a href="#identifacation-by-Delay-and-Bandwidth" class="headerlink" title="identifacation by Delay and Bandwidth"></a>identifacation by Delay and Bandwidth</h3><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><ul><li>带宽越大、延迟越大、host越多越容易识别成功</li></ul><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><ul><li><p>带宽越大越成功是因为</p><ul><li>归因于拥塞窗口的整数离散化，而最大cwnd取决于瓶颈带宽。 ( 我的理解就是：允许的cc窗口的区别度高 ）</li><li>以较大的带宽采样了诸如CUBIC的cubic行为的更多步骤。 较低的带宽意味着较少的采样步骤，并且三次行为很难与例如RENO的线性行为相区别。</li></ul></li><li><p>认为延迟越大越成功</p><ul><li>与histogram的bin-size  有关<blockquote><p>我个人在这里的理解就是： bin-size 就有点像分辨率 如果延迟太小，会导致整个图被横向压扁；如果延迟大一点，整个图就会舒展开，一些特征啥的会更加清晰，容易被CNN识别、提取到<br>有点意思 :)</p></blockquote></li></ul></li><li><p>认为多主机效果更好是因为</p><ul><li>对于相同的延迟，多主机情况也能获得更好的结果。我们将此影响归因于流量竞争。当link饱和时，单主机流的速率不会随着cwnd的增加而迅速增加，<strong>但是在多主机方案中增加流的cwnd可以增加其在队列中的数据包的份额，从而增加其速率。</strong> <strong>因此，对不同拥塞控制变量的cwnd的单独更改会对速率产生更大的影响，从而更强烈地影响数据包到达</strong>，并在更长的时间内影响较小的延迟和带宽问题。</li></ul></li></ul><p><strong>【感觉这一点实际上是利用了这三种方案面对竞争时候的特性有所区别的特点，并不是说：Competing的时候会有种让CC增加cwnd的动力(只有发的多才能收的快 收的快才能滑动)  ，而应该说：面对 competing的时候有不同的特性，有的人会趋于让cwnd增大，所以对应的包发得多，到达的间隔就短了】</strong></p><blockquote><p>如我们所见，<strong>带宽和延迟会影响我们的方法</strong>，延迟/带宽过小会导致识别性能降低。<strong>为了进一步评估，我们将以50Mbps作为带宽</strong>继续进行实验，以更好地了解该方法在何处面临挑战。 </p></blockquote>]]></content>
    
    <summary type="html">
    
      RL+CC
    
    </summary>
    
    
      <category term="PaperReading" scheme="http://yoursite.com/categories/PaperReading/"/>
    
    
      <category term="Network" scheme="http://yoursite.com/tags/Network/"/>
    
      <category term="Reinforcement Learning" scheme="http://yoursite.com/tags/Reinforcement-Learning/"/>
    
      <category term="Congestion Control" scheme="http://yoursite.com/tags/Congestion-Control/"/>
    
  </entry>
  
</feed>
