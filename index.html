<!DOCTYPE html><html lang="en,zh-CN,default"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#222"><meta name="generator" content="Hexo 5.0.0"><link rel="icon" type="image/png" sizes="16x16" href="/function%20()%20%7B%0A%20%20%20%20%20%20for%20(var%20_len2%20=%20arguments.length,%20args%20=%20new%20Array(_len2),%20_key2%20=%200;%20_key2%20%3C%20_len2;%20_key2++)%20%7B%0A%20%20%20%20%20%20%20%20args%5B_key2%5D%20=%20arguments%5B_key2%5D;%0A%20%20%20%20%20%20%7D%0A%0A%20%20%20%20%20%20return%20obj%5Bval%5D.apply(obj,%20args);%0A%20%20%20%20%7D"><link rel="stylesheet" href="/css/main.css"><link rel="stylesheet" href="//js.njzjz.win/npm/@fortawesome/fontawesome-free@5/css/all.min.css"><script id="hexo-configurations">var NexT=window.NexT||{},CONFIG={hostname:"yoursite.com",root:"/",scheme:"Gemini",version:"8.0.0-rc.4",exturl:!0,sidebar:{position:"left",display:"post",padding:18,offset:12},copycode:!0,bookmark:{enable:!0,color:"#222",save:"auto"},fancybox:!1,mediumzoom:!1,lazyload:!1,pangu:!1,comments:{style:"tabs",active:null,storage:!0,lazyload:!1,nav:null},algolia:{hits:{per_page:10},labels:{input_placeholder:"Search for Posts",hits_empty:"We didn't find any results for the search: ${query}",hits_stats:"${hits} results found in ${time} ms"}},localsearch:{enable:!0,trigger:"auto",top_n_per_article:1,unescape:!1,preload:!1},motion:{enable:!0,async:!1,transition:{post_block:"fadeIn",post_header:"slideDownIn",post_body:"slideDownIn",coll_header:"slideLeftIn",sidebar:"slideUpIn"}},prism:!1,path:"search.xml"}</script><meta name="description" content="some thoughts to share"><meta property="og:type" content="website"><meta property="og:title" content="Hesy&#39;s Blog"><meta property="og:url" content="http://yoursite.com/index.html"><meta property="og:site_name" content="Hesy&#39;s Blog"><meta property="og:description" content="some thoughts to share"><meta property="og:locale" content="en_US"><meta property="article:author" content="Hesy"><meta name="twitter:card" content="summary"><link rel="canonical" href="http://yoursite.com/"><script id="page-configurations">CONFIG.page={sidebar:"",isHome:!0,isPost:!1,lang:"en"}</script><title>Hesy's Blog - Seek for your love</title><noscript><style>body{margin-top:2rem}.use-motion .collection-header,.use-motion .comments,.use-motion .footer,.use-motion .header,.use-motion .menu-item,.use-motion .pagination,.use-motion .post-block,.use-motion .post-body,.use-motion .post-header,.use-motion .sidebar,.use-motion .site-brand-container .toggle{opacity:initial}.use-motion .custom-logo-image,.use-motion .site-subtitle,.use-motion .site-title{opacity:initial;top:initial}.use-motion .logo-line{transform:scaleX(1)}.search-pop-overlay,.sidebar-nav{display:none}.sidebar-panel{display:block}</style></noscript><link rel="alternate" href="/atom.xml" title="Hesy's Blog" type="application/atom+xml"></head><body itemscope itemtype="http://schema.org/WebPage"><div class="container use-motion"><div class="headband"></div><main class="main"><header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="header-inner"><div class="site-brand-container"><div class="site-nav-toggle"><div class="toggle" aria-label="Toggle navigation bar"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div></div><div class="site-meta"><a href="/" class="brand" rel="start"><i class="logo-line"></i><h1 class="site-title">Hesy's Blog</h1><i class="logo-line"></i></a><p class="site-subtitle" itemprop="description">Seek for your love</p></div><div class="site-nav-right"><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class="site-nav"><ul id="menu" class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>Home</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>Categories<span class="badge">2</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>Archives<span class="badge">3</span></a></li><li class="menu-item menu-item-tags"><a href="/tags" rel="section"><i class="fa fa-tag fa-fw"></i>Tags<span class="badge">3</span></a></li><li class="menu-item menu-item-search"><a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>Search</a></li></ul></nav><div class="search-pop-overlay"><div class="popup search-popup"><div class="search-header"><span class="search-icon"><i class="fa fa-search"></i></span><div class="search-input-container"><input autocomplete="off" autocapitalize="off" placeholder="Searching..." spellcheck="false" type="search" class="search-input"></div><span class="popup-btn-close"><i class="fa fa-times-circle"></i></span></div><div id="search-result"><div id="no-result"><i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i></div></div></div></div></div><div class="toggle sidebar-toggle"><span class="toggle-line toggle-line-first"></span> <span class="toggle-line toggle-line-middle"></span> <span class="toggle-line toggle-line-last"></span></div><aside class="sidebar"><div class="sidebar-inner sidebar-overview-active"><ul class="sidebar-nav"><li class="sidebar-nav-toc">Table of Contents</li><li class="sidebar-nav-overview">Overview</li></ul><section class="post-toc-wrap sidebar-panel"></section><section class="site-overview-wrap sidebar-panel"><div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="site-author-image" itemprop="image" alt="Hesy" src="/img/avatar-hexi.jpg"><p class="site-author-name" itemprop="name">Hesy</p><div class="site-description" itemprop="description">some thoughts to share</div></div><div class="site-state-wrap motion-element"><nav class="site-state"><div class="site-state-item site-state-posts"><a href="/archives/"><span class="site-state-item-count">3</span> <span class="site-state-item-name">posts</span></a></div><div class="site-state-item site-state-categories"><a href="/categories/"><span class="site-state-item-count">2</span> <span class="site-state-item-name">categories</span></a></div><div class="site-state-item site-state-tags"><a href="/tags"><span class="site-state-item-count">3</span> <span class="site-state-item-name">tags</span></a></div></nav></div><div class="links-of-author motion-element"><span class="links-of-author-item"><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hleGk1MTk=" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;hexi519"><i class="fab fa-github fa-fw"></i>GitHub</span> </span><span class="links-of-author-item"><span class="exturl" data-url="bWFpbHRvOmhlc3k1MTlAZ21haWwuY29t" title="E-Mail → mailto:hesy519@gmail.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</span> </span><span class="links-of-author-item"><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hlc3lfSA==" title="CSDN → https:&#x2F;&#x2F;blog.csdn.net&#x2F;Hesy_H"><i class="fab fa-plug fa-fw"></i>CSDN</span></span></div><div class="cc-license motion-element" itemprop="license"><span class="exturl cc-opacity" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC8="><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></span></div><div class="links-of-blogroll motion-element"><div class="links-of-blogroll-title"><i class="fa fa-link fa-fw"></i> Friend Links</div><ul class="links-of-blogroll-list"><li class="links-of-blogroll-item"><span class="exturl" data-url="aHR0cDovL25qemp6Lndpbg==" title="http:&#x2F;&#x2F;njzjz.win">学神(Jinzhe Zeng)</span></li></ul></div></section></div></aside><div id="sidebar-dimmer"></div></header><div class="back-to-top"><i class="fa fa-arrow-up"></i> <span>0%</span></div><div class="reading-progress-bar"></div><a role="button" class="book-mark-link book-mark-link-fixed"></a> <span class="exturl github-corner" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hleGk1MTkv" title="Follow me on GitHub" aria-label="Follow me on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin:130px 106px" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></span><noscript><div id="noscript-warning">Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner"><div class="content index posts-expand"><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en,zh-CN,default"><link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/30/siteBuilding/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/img/avatar-hexi.jpg"><meta itemprop="name" content="Hesy"><meta itemprop="description" content="some thoughts to share"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Hesy's Blog"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2020/07/30/siteBuilding/" class="post-title-link" itemprop="url">建站 | Jekyll -》 mkdocs -》 hexo</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2020-07-30 21:50:53 / Modified: 23:19:39" itemprop="dateCreated datePublished" datetime="2020-07-30T21:50:53+08:00">2020-07-30</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">In</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/%E7%A8%8B%E5%BA%8F%E5%91%98%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/" itemprop="url" rel="index"><span itemprop="name">程序员的自我修养</span></a></span></span><br><span class="post-meta-item" title="Symbols count in article"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">Symbols count in article: </span><span>1k</span> </span><span class="post-meta-item" title="Reading time"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">Reading time &asymp;</span> <span>1 mins.</span></span></div></header><div class="post-body" itemprop="articleBody"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="Jekyll"><a href="#Jekyll" class="headerlink" title="Jekyll"></a>Jekyll</h1><p>之前是用的jekyll，但是没找到我想要的全局搜索功能，有兴趣的还是可以看下：<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hlc3lfSC9hcnRpY2xlL2RldGFpbHMvMTA0MTg0NzIw">Jekyll建站<i class="fa fa-external-link-alt"></i></span></p><hr><h1 id="mkdocs"><a href="#mkdocs" class="headerlink" title="mkdocs"></a>mkdocs</h1><blockquote><p>其实Jekyll已经省去了很多麻烦了，但是我真的真的很烦每个md开头要写一大段乱七八糟的配置，不方便迁移，所以就转到mkdocs了，虽然模板的页面效果没有Jekyll丰富，但是对懒人还是极其友好的。</p></blockquote><blockquote><p>本来想用mkdocs的，毕竟还是挺省事儿的，文件结构也很清晰，学神点拨下我发现hexo可以全局搜索，跟mkdocs的标题搜索等级比起来，更香了！<br>简单学了下，后续可能考虑用mkdocs做一些项目文档手册，作为子网址吧，做手册挺合适的。</p></blockquote><h2 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h2><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cueG5jb2RpbmcuY29tLzIwMjAvMDMvMDEvdG9vbC9ta2RvY3MuaHRtbA==">蛮详细的，尤其是关于yml配置文件相关的<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cDovL3d1dG9uZ3RyZWUuZ2l0aHViLmlvL2Rldm9wcy9tYW5hZ2UteW91ci1jbXMtdXNpbmctbWtkb2Nz">配置也很详细，尤其有一些关于mkdocs的冷知识<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly9teS5vc2NoaW5hLm5ldC9menhpYW9tYW5nZS9ibG9nLzMwMTA5MjE=">列了一些注意事项，which我也觉得很重要<i class="fa fa-external-link-alt"></i></span></li><li>这个没仔细看，但是感觉很高贵的样子 <span class="exturl" data-url="aHR0cHM6Ly90b3V0aWFvLmlvL3Bvc3RzL3Q5M2E1Yy9wcmV2aWV3">将 Jupyter 自动发布到 GitHub Pages<i class="fa fa-external-link-alt"></i></span></li></ul><h2 id="配置中遇到的问题"><a href="#配置中遇到的问题" class="headerlink" title="配置中遇到的问题"></a>配置中遇到的问题</h2><p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N0b25lOTE1OS9hcnRpY2xlL2RldGFpbHMvNzkwNzEzMTY=">py37下字符编码遇到的问题<i class="fa fa-external-link-alt"></i></span></p><hr><h1 id="hexo"><a href="#hexo" class="headerlink" title="hexo"></a>hexo</h1><blockquote><p>我的两个config.xml都做了比较详细的注释，大家改起来也会很方便，欢迎fork！（虽然我本来也就是改学神的2333</p></blockquote><h2 id="ref-1"><a href="#ref-1" class="headerlink" title="ref"></a>ref</h2><ol><li><p>环境配置请参考：<span class="exturl" data-url="aHR0cHM6Ly9scnNjeS5naXRodWIuaW8vMjAxNy8xMS8xMC9VYnVudHUtR2l0aHViLWlvLWNvbmZpZy1IZXhvLw==">linux下使用hexo建站<i class="fa fa-external-link-alt"></i></span></p><blockquote><ul><li>安装的时候提示8.x已经deprecated，所以我按照提示安装了12.x</li><li>在服务器上跑<code>npm install -g hexo-cli</code>等命令的时候，会遇到权限不够，根据提示给sudo就行</li></ul></blockquote></li><li><p>推送过程和基本配置可以参照<span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC9kOWYwNDBmOWMyZTM=">这个<i class="fa fa-external-link-alt"></i></span></p><blockquote><ul><li>next主题的仓库已经过期，我用的是学神给的这个：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3RoZW1lLW5leHQvaGV4by10aGVtZS1uZXh0">https://github.com/theme-next/hexo-theme-next<i class="fa fa-external-link-alt"></i></span></li><li><span class="exturl" data-url="aHR0cHM6Ly90ZGluZy50b3AvYXJjaGl2ZXMvNDJjMzhiMTAuaHRtbA==">next主题的基本设置<i class="fa fa-external-link-alt"></i></span></li></ul></blockquote></li><li><p>其他trivis的可选功能</p><blockquote><ul><li><span class="exturl" data-url="aHR0cHM6Ly93d3cuamlhbnNodS5jb20vcC9kNjhkZTA2N2VhNzQ=">Hexo添加Disqus评论<i class="fa fa-external-link-alt"></i></span></li><li>hexo添加google-analytic功能 （ 不想做了2333累了</li></ul></blockquote></li></ol><h2 id="基本命令"><a href="#基本命令" class="headerlink" title="基本命令"></a>基本命令</h2><p>hexo new ‘文章标题’<br>hexo new draft<br>hexo clean</p><blockquote><p>清除缓存文件 (db.json) 和已生成的静态文件 (public)。在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。</p></blockquote><p>hexo g<br>hexo s<br>hexo d</p><hr><h1 id="mkdown-图床-获取-永久链接-（-香"><a href="#mkdown-图床-获取-永久链接-（-香" class="headerlink" title="mkdown+图床 获取 永久链接 （ 香"></a>mkdown+图床 获取 永久链接 （ 香</h1><p>可以参考<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hlc3lfSC9hcnRpY2xlL2RldGFpbHMvMTA3NjIyMjAy">我之前写的文章：typora+gitee图床<i class="fa fa-external-link-alt"></i></span></p><hr><h1 id="actions"><a href="#actions" class="headerlink" title="actions"></a>actions</h1><p><span class="exturl" data-url="aHR0cHM6Ly9qdWVqaW4uaW0vcG9zdC81YzQxN2RhNzUxODgyNTI1YzYzODA5Y2Q=">简单入个门<i class="fa fa-external-link-alt"></i></span><br>本来想自己写的，结果学神也用的action，哈哈作业一抄到底 （ docker确实不会啊… - -||| ）</p><hr><h1 id="miscelleous"><a href="#miscelleous" class="headerlink" title="miscelleous"></a>miscelleous</h1><ul><li>添加多个部署源<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">deploy</span>:</span><br><span class="line">- <span class="attribute">type</span>: git</span><br><span class="line">  <span class="attribute">repo</span>:</span><br><span class="line">- <span class="attribute">type</span>: heroku</span><br><span class="line">  <span class="attribute">repo</span>:</span><br></pre></td></tr></table></figure></li></ul></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en,zh-CN,default"><link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/05/PaperReading/RNN%20Prediction%20of%20TCP%20Transmission%20States(NCA'18)/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/img/avatar-hexi.jpg"><meta itemprop="name" content="Hesy"><meta itemprop="description" content="some thoughts to share"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Hesy's Blog"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2020/02/05/PaperReading/RNN%20Prediction%20of%20TCP%20Transmission%20States(NCA'18)/" class="post-title-link" itemprop="url">RNN Prediction of TCP Transmission States(NCA'18)</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2020-02-05 13:00:00" itemprop="dateCreated datePublished" datetime="2020-02-05T13:00:00+08:00">2020-02-05</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">Edited on</span> <time title="Modified: 2020-07-30 22:25:46" itemprop="dateModified" datetime="2020-07-30T22:25:46+08:00">2020-07-30</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">In</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/PaperReading/" itemprop="url" rel="index"><span itemprop="name">PaperReading</span></a></span></span><br><span class="post-meta-item" title="Symbols count in article"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">Symbols count in article: </span><span>12k</span> </span><span class="post-meta-item" title="Reading time"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">Reading time &asymp;</span> <span>11 mins.</span></span></div></header><div class="post-body" itemprop="articleBody"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>NCA’18 @ IEEE (network computing and application)</p><h2 id="abstract"><a href="#abstract" class="headerlink" title="abstract"></a>abstract</h2><blockquote><p>关于序列学习和时间序列预测模型，长短期记忆（LSTM）神经网络是最先进的技术。在本文中，我们已使用基于LSTM的递归神经网络（RNN）为被动测量建立传输控制协议（TCP）连接特性的通用预测模型。据我们所知，这是尝试将LSTM应用于展示网络运营商如何识别可确定网络状况的TCP客户端最重要的系统范围TCP每连接状态（例如cwnd）的第一项工作。从网络中间节点测得的无源流量中获取，而无需访问发送方。我们发现LSTM学习者的表现优于最新的经典机器学习预测模型。通过在多种情况下进行的广泛实验评估，我们证明了该方法的可扩展性和鲁棒性，以及其从被动测量中监视与网络拥塞相关的TCP传输状态的潜力。我们基于仿真和现实环境的结果表明，深度学习是一种用于从被动测量监视系统范围TCP状态的有前途的工具，并且我们相信本文中介绍的方法可以加强计算机网络社区的未来研究工作。</p></blockquote><p>看起来是根据中间节点的信息去预测终端的拥塞窗口等属性 ?</p><h2 id="1-introduction"><a href="#1-introduction" class="headerlink" title="1 introduction"></a>1 introduction</h2><p>在本文中，我们对基于仿真和现实网络的RNN模型估计TCP cwnd的能力以及流中的基础TCP变体感兴趣。</p><blockquote><p>因此，我们探索了一种基于RNN的预测方法的LSTM架构，以通过与网络拥塞相关的被动测量来监视最重要的TCP每个连接状态。在我们的论文中，我们证明了LSTM可以使用其内存块和一系列门来有效地从被动测量中捕获TCP cwnd的模式。拥塞控制是计算机网络中的一个基本问题。当今广泛部署的TCP拥塞控制算法执行了与拥塞控制相关的最重要功能，例如从发送方处理cwnd。</p></blockquote><p>在本文中，我们定量地研究和探索了问题，因为这些问题适用于网络拥塞问题，其中包括：</p><ul><li>我们如何能够根据从网络的中间节点收集到的passive traffic中，很好地推断出最重要的TCP每连接传输状态，？ 【怎么建模】<blockquote><p>?? 不知道如何翻译 infer the most important TCP per-connection transmission states that determine a network condition</p><ul><li>如何从被动测量中唯一地跟踪TCP客户端使用的underlying TCP variant？ 【如何判别TCP variant】</li></ul></blockquote></li><li>为什么需要知道TCP发送者使用哪种算法是什么？</li><li>在了解发送方的基础TCP变体的信息之后，我们是否会采取某些措施？</li><li>哪个用户负责网络中的大部分繁忙流量？等等。？<blockquote><p>(i) How well can we infer the most important TCP per-connection transmission states that determine a network condition from a passive traffic collected at an intermediate node of the network?<br>(ii) How can we uniquely track the underlying TCP variant that the TCP client is using from passive measurements?<br>(iii) What is the motivation why we need to know which algorithm the TCP sender is using? (iv) Is there some action that we would take based on knowing the information of the underlying TCP variant of the sender?<br>(v) Which user is responsible for the majority of heavy flow traffic in the network? etc.?</p></blockquote></li></ul><h3 id="前人工作"><a href="#前人工作" class="headerlink" title="前人工作"></a>前人工作</h3><blockquote><ul><li>先喷了04年的一篇文章 用状态机建模的 讲了两个缺陷 一个是可扩展性-》每个TCP variant都会需要建立一个状态机模型；另一个就是…（看文章叭）<br>然后就说没啥前人工作了。。。</li></ul></blockquote><p><code>&quot;在我们广泛地调查了现有的从被动测量监测TCP传输状态的工作之后，我们相信，对于使用基于RNN的技术的大多数广泛使用的TCP变体，在不知道发送方cwnd的情况下，对于预测cwnd和从被动通信量中唯一识别底层TCP控制算法类型的可伸缩方法，目前还没有太多的工作&quot;</code></p><blockquote><p>据我们所知，这是第一项尝试使用LSTM [14]来推断最重要的TCP每连接状态的工作，该状态根据网络中间节点收集的被动流量确定了网络状况，而没有sender的访问权限。正如我们在实验结果中所展示的，我们的预测模型比其他方法有很多好处。</p></blockquote><h3 id="本文贡献"><a href="#本文贡献" class="headerlink" title="本文贡献"></a>本文贡献</h3><ul><li>使用中间节点的被动测量信息和LSTM模型进行建模</li><li>方法是健壮、可扩展的</li><li>在模拟器上train，迁移到实际环境中效果不错</li><li>我们通过几个受控实验(controlled exp 不知道咋翻译..)广泛验证了我们的预测模型的鲁棒性和可扩展性方法，并在模拟，现实和组合场景设置中进行了实验验证。</li></ul><blockquote><p>• 我们演示了中间节点（例如，网络运营商）如何识别与TCP流相关的TCP客户端的传输状态，并使用LSTM递归模型根据被动测量预测发送方的拥塞窗口（cwnd）大小。<br>•我们通过提供一个健壮和可扩展的方法来唯一标识TCP客户端正在使用的广泛部署的基础TCP变量，从而探索基于LSTM的预测模型的适用性。<br>•我们证明，通过在实际场景设置中应用和转移模拟网络中的训练有素的知识，学习的预测模型可以很好地发挥作用。因此，我们的预测模型与机器学习社区中的转移学习概念大致相似[26]。<br>•我们通过几个受控实验广泛验证了我们的预测模型的鲁棒性和可扩展性方法，并在模拟，现实和组合场景设置中进行了实验验证。</p></blockquote><h2 id="2-motivation"><a href="#2-motivation" class="headerlink" title="2 motivation"></a>2 motivation</h2><p>我们的工作主要是由第一节中提出的问题引起的。拥塞控制算法在提高Internet上TCP的性能方面起着至关重要的作用[6]。但是，==当TCP算法的不同变体共存于网络中时，它们可能相互影响==。<br>==解决此问题的一种方法是通过预测cwnd并唯一标识基础TCP变量来单独控制TCP流。==</p><h3 id="Benefits"><a href="#Benefits" class="headerlink" title="Benefits"></a>Benefits</h3><p>讲了两个实际中该问题的应用背景 :</p><ul><li>可以唯一识别(identify)每个TCP连接，可以看看内容提供商有没有超额使用(TCP不公平现象检测)</li><li>从中间节点推测出更多信息，用于诊断拥塞原因</li></ul><blockquote><p>从运营的角度来看，此信息对于网络运营商(network operators)很有用，以监控主要内容提供商(content providers)（例如Google，Facebook，Netflix，Akamai等）是否正在操纵其服务器中的拥塞窗口，以实现超出其公平份额的目标带宽。运营商可能会发现此信息有用的另一种情况是，他们是否拥有一条由于客户投诉而导致其拥堵的路径，但是使用该路径的链接并没有被特别地订阅。在这种情况下，有关该路径上所有用户的拥塞窗口行为的详细信息可能有助于尝试诊断原因。从ISP的角度来看，我们认为有关端点中使用的TCP堆栈的知识对于进行大量流量工程和异常检测的大型ISP网络的运营商很有用[12]。</p></blockquote><h3 id="Methodological-Challenges"><a href="#Methodological-Challenges" class="headerlink" title="Methodological Challenges"></a>Methodological Challenges</h3><p>实践中；但是，从被动测量中预测TCP每个连接状态有许多困难。挑战之一是，例如，TCP数据包可能在发送方和中间监视器之间或监视器与接收方之间丢失。如果TCP数据包在到达中间节点之前丢失，并以某种方式重新传输，则无法确定是否发生了数据包丢失。因此，==中间监视器所看到的可能与发送方或接收方所看到的不完全相同。== 在[10]中更详细地介绍了我们确定的方法挑战，这些挑战涉及从被动测量中进行与网络拥塞相关的TCP每个连接状态的推断。在本文中，我们主张通过解决上述实际挑战，基于LSTM的方法可以从在中间节点收集的被动测量结果中提供更好的TCP发送方连接状态预测精度。</p><h3 id="Roadmap"><a href="#Roadmap" class="headerlink" title="Roadmap"></a>Roadmap</h3><blockquote><p>本文的其余部分安排如下：在第三节中，我们回顾并详细概述了被视为最新技术的TCP被动测量的紧密相关研究工作。在第四节中，我们描述了用于评估的实验装置。第五部分概述了我们的方法，重点介绍了本文中使用的机器学习技术和性能测量指标。第六节介绍了详细的实验结果以及用于验证我们的预测模型的多种方案设置。最后，第七节总结了论文并概述了未来扩展的研究方向。</p></blockquote><h2 id="3-related-work"><a href="#3-related-work" class="headerlink" title="3 related work"></a>3 related work</h2><p>本节简要讨论了有关通过被动测量来推断与网络拥塞相关的TCP每连接状态的紧密相关的研究工作。监视TCP每连接特征的技术分为两类：主动和被动测量。</p><p>主动测量</p><blockquote><p>已经提出的许多现有研究工作都依靠主动方法来测量TCP的特征。通过向至少两个端点之间的网络中注入人工流量，该技术可以主动测量Internet流的TCP行为[22，25]。它主要侧重于主动网络监视，并依赖于注入特定流量的能力，然后对其进行监视，以衡量从网络获得的服务。</p></blockquote><p>被动测量</p><blockquote><p>在被动测量中，检查被动收集的数据包迹线以测量Internet流的TCP行为[16]。</p><p>与我们的工作最密切相关的一项有趣的工作是[16]，它提供了一种被动的测量方法来推断和保持跟踪发件人变量：end-to-endRTT和cwnd的值。他们的想法是通过在发送方检测重传超时（RTO）事件并观察导致发送方更改cwnd值的ACK来模拟状态转换。这项工作[16]仅考虑了TCP的主要实现，其基本思想是为在中间节点观察到的每个TCP连接构造一个TCP发送者状态的副本。副本采用有限状态机的形式。但是，考虑到许多现有的TCP变体，无法对每个变体使用单独的状态机。我们还认为，考虑到大量数据，构造的副本[16]无法设法使转换反向或回溯。另一个限制是副本可能无法观察到与发送方相同的数据包序列，并且在中间节点处观察到的ACK也可能不会到达发送方。</p><p>==该研究的作者[27]开发了一种名为tcpflows的工具，该工具试图通过分析ACK流来检测TCP拥塞事件的发生，从而被动地估计cwnd的值并识别TCP拥塞控制算法。== 但是，使用tcpflowsis实现的状态机仅限于旧的TCP变体，因此无法唯一标识新的TCP拥塞控制算法。</p></blockquote><blockquote><p>我们的工作与以前的工作主要不同，我们的主要目标是从根本上开发一种==可扩展的基于LSTM的预测模型==，以便为使用最广泛的==基于损耗的拥塞算法==推断TCPper-connection状态。如果仅查看一个或两个TCP变体，则不同的TCP堆栈具有多种功能，这些功能将违反我们可能做出的假设。因此，在我们的工作中，为了覆盖问题的整个范围，我们考虑了使用最广泛的基于损耗的TCP算法变体，它们是==BIC [32]，CUBIC [9]和Reno [15]。==</p></blockquote><p>==这里提到了[27]A Passive State-Machine Based Approach for Reliable Estimation of TCP Losses. 2006 也是用于检测拥塞的 只不过还有局限性==</p><h2 id="EXPERIMENTAL-SETUP-AND-DISCUSSION"><a href="#EXPERIMENTAL-SETUP-AND-DISCUSSION" class="headerlink" title="EXPERIMENTAL SETUP AND DISCUSSION"></a>EXPERIMENTAL SETUP AND DISCUSSION</h2><h3 id="A-Experimental-Testbed"><a href="#A-Experimental-Testbed" class="headerlink" title="A. Experimental Testbed"></a>A. Experimental Testbed</h3><p>图2显示了本文中用于所有实验的实验设置。</p><ul><li>仿真网络+一条通信隧道以引入拥塞</li><li>iperf生成TCP流量</li><li>单个TCP流中的参数带宽和延迟是恒定的，并且分布均匀；抖动作为平均值给出，因此其分布是正态的</li><li>我们在客户端节点上创建了相同的regular tcpdump of TCP packets，其中包括有关每个连接状态的信息，以便我们可以将tcpdump与TCP状态进行匹配。<blockquote><p>We created an identical regular tcpdump of the TCP packets on the client node including information about the per-connection states so that we can match the tcpdump with the TCP states.</p></blockquote></li><li>将测得的TCP数据当作输入，以预测TCP每个连接状态。使用Linux内核直接记录的实际TCP内核状态（仅用于培训）验证了预测的TCP状态，并为学习模型生成了新数据以进行预测。<blockquote><p>为了引入拥塞，我们首先创建了一个仿真网络，并在网络上放置了一条通信隧道，同时使用iperf流量生成器将TCP跨流量推送到网络[7]。我们通过捕获客户端和服务器发送TCP数据包时网络上的所有会话来进行实验。在我们实验的单个TCP流中，参数带宽和延迟是恒定的，并且分布均匀。但是，由于我们将抖动作为平均值给出，因此其分布是正态的。我们在客户端节点上创建了相同的常规TCP数据包tcpdump，其中包括有关每个连接状态的信息，以便我们可以将tcpdump与TCP状态进行匹配。如图2所示，我们将测得的TCP数据用作我们的方法输入，以预测TCP每个连接状态。最后，我们使用直接从Linux内核直接记录的实际TCP内核状态（仅用于培训）验证了预测的TCP状态，并为学习模型生成了新数据以进行预测。完成验证后，我们将运行学习模型并获得预测.</p></blockquote></li></ul><h3 id="B-Testbed-Hardware"><a href="#B-Testbed-Hardware" class="headerlink" title="B.Testbed Hardware"></a>B.Testbed Hardware</h3><blockquote><p>我们已经使用了一组基于GNU / Linux操作系统的HPC计算机集群进行了实验，该操作系统运行4.4.0-75-通用内核发行版的修改版。该预测模型是在具有以下特征的NVIDIA Tesla K80 GPU加速器计算上执行的：Intel（R）Xeon（R）CPU E5-2670 v3 @ 2.30GHz，64个CPU处理器，128GB RAM，在Linux 64-一点。群集中的所有节点都连接到低延迟56 Gbit / s Infiniband，千兆以太网，并可以访问600 TiB的BeeGFS并行文件系统存储。</p></blockquote><h3 id="C-Network-Emulation-and-Verification-of-the-emulator"><a href="#C-Network-Emulation-and-Verification-of-the-emulator" class="headerlink" title="C. Network Emulation and Verification of the emulator"></a>C. Network Emulation and Verification of the emulator</h3><p>==对于网络仿真，我们在单独的节点上使用了基于Linux的流行网络仿真器（NetEm）[13]，该仿真器支持带宽，延X迟，抖动，丢包和其他参数的等对cwnd赢下给比较大的参数。==</p><ul><li>另一个问题是软件仿真器不够精确 ——》 作者在此提出了一个验证方法(具体没有怎么看懂，也许并不重要??)</li></ul><blockquote><p>鉴于软件仿真器不够精确，我们是否可以信任网络仿真器来评估我们为评估而更改的所有带宽，延迟，抖动和丢包参数的变化，而不考虑我们从TCP流获得的测量结果？<br>为了在极为完善的环境中谨慎使用网络仿真器来处理所有参数的变化，我们创建了一个过滤器来设置每个数据包的参数变化。由于无法从TCP流中测量仿真器的精度，因此我们使用UDP进行了另一项实验，以评估和测量仿真器和流量生成器均会产生偏差的精度。<br>我们通过测量由接收方的流量生成器和网络仿真器创建的带宽，延迟，抖动和数据包丢失变化来验证原始性能。</p><p>Given that the software emulator is not precise, can we trust the network emulator for all the variations of bandwidth, delay, jitter and packet loss parameters that we change for our evaluation irrespective of the measurement we get from TCP stream?</p><p>In order to use the network emulator with great care in an extremely well-contained environment for all the variations of the parameters, we created a filter that sets the parameter variation of each packet. As the precision of the emulator cannot be measured from TCP streams, we set up a different experiment using UDP to evaluate and measure the precision where both the emulator and traffic generator create variations.</p><p>We verified the raw performance by measuring the bandwidth, delay, jitter and packet loss variations created by the traffic generator and network emulator at the receiver side.</p></blockquote><h3 id="D-Impact-of-Cross-traffic-Variability"><a href="#D-Impact-of-Cross-traffic-Variability" class="headerlink" title="D. Impact of Cross-traffic Variability"></a>D. Impact of Cross-traffic Variability</h3><p>结论：</p><ul><li>仿真器运行的每个变化都不会影响我们的结果–》交叉流量的可变性不会影响我们的分析</li><li>cwnd可变性取决于所使用的特定TCP拥塞控制</li><li>仿真器可能会受到其范围之外的网络元素的影响，例如CPU负载，网卡缓冲区，硬件架构因素等<blockquote><p>我们运行NetEm [13]时，客户端和服务器之间的数据速率和仿真参数有所不同。我们通过模拟其他UDP流量，仔细研究并验证了来自同一TCP拥塞协议的跨业务量变化对结果的影响，我们发现，仿真器运行的每个变化都不会影响我们的结果。我们认为，在当前设置中交叉流量的可变性不会影响我们的分析。通常，当涉及到cwnd可变性时，它将取决于所使用的特定TCP拥塞控制。我们还认为，仿真器可能会受到其范围之外的网络元素的影响，例如CPU负载，网卡缓冲区，硬件架构因素等。</p></blockquote></li></ul><h3 id="E-Network-Traces"><a href="#E-Network-Traces" class="headerlink" title="E. Network Traces"></a>E. Network Traces</h3><h3 id="F-Network-Emulation-Parameters"><a href="#F-Network-Emulation-Parameters" class="headerlink" title="F. Network Emulation Parameters"></a>F. Network Emulation Parameters</h3><p>为了在仿真和实际网络条件下评估我们的预测模型，我们使用tcptrace [24]生成了自己的数据集。我们所有实验的数据轨迹都是使用iperf [7]流量生成器在模拟的LAN链路上生成的，在该LAN链路上，我们运行每个TCP变量，并改变了参数带宽，延迟，抖动和数据包丢失，如表I所示，其中cwnd极其受影响。==但是，内核可能会将数据包的TCP每次连接状态保留在缓冲区中，并等待足够数量的数据包，然后再将TCP状态发送到用户空间。由于用户空间进程的TCP进程缓慢，TCP的每个连接状态也可能会丢失。==</p><p>？？<br>因此，作为合理性检查(sanity check)，我们要做的第一件事就是在发送方和接收方都捕获数据包，因为它有助于我们知道数据包是丢失还是从未发送过，因为从接收方到发送方的ACK与数据包以推断数据包丢失。这样，可以验证流量捕获是否相同，并且每个连接的TCP状态都没有丢失。</p><p>为了避免丢失数据包并在发送方上和monitor上捕获完全相同数量的数据包，我们执行的第二件事是==调整缓冲区大小并将缓冲区刷新到用户空间==。通过禁用TCP分段卸载，我们在巨型帧清洁的路径上进行了实验，从而可以避免数据包大小超过常规合法大小。</p><blockquote><p>Therefore, the first thing we did as a sanity check is to capture the packets at both the sender and the receiver for it helps us to know whether a packet was lost or just never sent as the ACKs from receiver to sender are just as important as the data packets for inferring packet loss. This way, it is possible to verify if the traffic captures are identical and there are no missing per-connection TCP states.</p><p>The second thing we carried out in order to avoid missing of packets and capture exactly the same number of packets on the sender and the monitor is tuning the buffer size and flush the buffer to the userspace. We carried out our experiment over a path that is jumbo-frame clean by disabling TCP segmentation offloading so that we can avoid packet sizes way over the regular legitimate size.</p></blockquote><p>TCP拥塞控制设置为根据带宽，不同的交叉流量，RTT等的可变性进行操作。因此，为了创建现实的场景，我们在设置中模拟了网络，如图2所示，通过在一条流中向表I中列出的重要网络仿真参数添加可变性。</p><h3 id="G-Assumptions"><a href="#G-Assumptions" class="headerlink" title="G. Assumptions"></a>G. Assumptions</h3><p>在TCP中，cwnd是决定随时可以处理的字节数的主要因素之一。 因此，我们假设在存在带宽变化，延迟， 损失和RTT情况下，使用（大概理解为bytes in flight)==the observed outstanding sequence of unacknowledged bytes on the network seen at any point in time in the lifetime of the connection as an estimate of the sending TCP’s cwnd from tcptrace==是一种更好的方法来估算cwnd以及恢复速度的方法。<br>首先，由于我们是根据飞行中的字节估算cwnd的，因此我们还考虑了cwnd肯定是是发送方的限制因素的事实，以及cwnd必须小于接收方的窗口的事实。<br>其次，我们假设我们不知道网络中正在运行什么TCP变体以及该变体中的每个连接状态。<br>最后，我们在本文中给出的结果是基于如下假设的:端点具有与操作系统无关的、由底层操作系统独立设置的相同接收器窗口(receiver window)。</p><h2 id="5-METHODOLOGY"><a href="#5-METHODOLOGY" class="headerlink" title="5 METHODOLOGY"></a>5 METHODOLOGY</h2><p>本节说明了我们用于通过基于RNN的技术从被动测量中通过实验推断cwnd和唯一标识基础TCP变体的通用方法。</p><h3 id="A-Passive-Monitoring-of-bytes-in-flight"><a href="#A-Passive-Monitoring-of-bytes-in-flight" class="headerlink" title="A. Passive Monitoring of bytes in flight"></a>A. Passive Monitoring of bytes in flight</h3><p>TCP拥塞控制算法通过使用cwnd来控制TCP发送方的发送速率，该cwnd限制了在任何给定时间允许的累积未确认字节的数量。 如图2所示，在中间节点处收集的测得的被动TCP数据用于我们模型的训练实验。 在监视点看不到TCP实现的详细信息和TCP选项的使用。 TCP发送器还通过内核中的两个变量来跟踪未完成的字节：snd nxt（要发送的下一个数据包的序列号）和snd una（最小的未确认序列号）。</p><h3 id="B-Prediction-of-TCP-cwnd-from-Passive-Traffic"><a href="#B-Prediction-of-TCP-cwnd-from-Passive-Traffic" class="headerlink" title="B. Prediction of TCP cwnd from Passive Traffic"></a>B. Prediction of TCP cwnd from Passive Traffic</h3><p>cwnd是TCP每次连接状态内部变量，表示发送者可以根据发送者的网络容量和条件在任何给定时间点潜在传输的最大数据量。 TCP [15]使用cwnd来确定在任何给定时间没有被发送方独立维护以进行拥塞避免的情况下，未确认的最大字节数。图3显示了在运行神经模型和应用LSTM技术之前，来自中间节点的未完成字节数与从发送方内核跟踪的实际cwnd之间在时间方面的比较。</p><blockquote><p>考虑到TCP的本质，通过检查中间节点被动收集的端点的TCP流的每个交叉流量来准确推断发送者的cwnd是一项具有挑战性的任务，因为它不做广告。我们尝试估计cwnd的一种初始方法是处理tcpdump中流的数据包头，并根据跟踪集计算汇总的TCP交叉流量，并将其添加为asa功能。然而，我们在实验中发现对于准确的预测而言，细节不足。在本文中，我们认为利用基于RNN的算法训练分类器和预测模型来从被动测量中预测cwnd非常重要。</p></blockquote><p><strong>Learning Context</strong></p><blockquote><p>我们使用带有TensorFlow后端的Keras深度学习框架，构建了高度健壮且可扩展的基于RNN的预测模型，</p></blockquote><ul><li>cwnd批量大小为32。</li><li>在t的每个时间步长处，LSTM模型都将飞行中的未完成字节的整个数组作为输入特征向量（x），该向量由从内核获得的时间戳索引。</li><li>多层LSTM单元 + 15维隐藏状态的dense layer + ReLU激活函数(==?最后一层居然也ReLU==) –&gt; 输出 a sequence dimensional vector of predicted cwnd (y) of the same size indexed by time stamp.</li><li>经过时间截断的反向传播（TBPTT）训练算法进行训练 | Adam 默认学习速率为0.001 | RMSE 和 MAPE(Mean Absolute Percentage<br>Error) 同时作为损失函数的评价指标 (？具体怎么综合起来的待后面考查)</li></ul><h3 id="C-Prediction-of-TCP-Variants"><a href="#C-Prediction-of-TCP-Variants" class="headerlink" title="C. Prediction of TCP Variants"></a>C. Prediction of TCP Variants</h3><p>对于基本的TCP变体预测任务，仅考虑了基于丢包的TCP拥塞控制算法(loss-based)(e.g., CUBIC [9] BIC [32], and Reno [15]) 用预测出来的cwnd去判断β值(back-off parameter) &lt;– 对于AIMD的拥塞控制算法来说，β值是一个很典型的特征。</p><h2 id="6-EXPERIMENTS-AND-RESULTS"><a href="#6-EXPERIMENTS-AND-RESULTS" class="headerlink" title="6 EXPERIMENTS AND RESULTS"></a>6 EXPERIMENTS AND RESULTS</h2><blockquote><p>本节总结了几个实验结果。针对每个TCP做了36种配置，如表I所示，总共216种在实验(?咋算的..)实验评估中，给出其中一个测试方案配置并给出CUBIC [9]，BIC [32]和Reno [15]三个baseline的测试效果。</p></blockquote><p>==TCP cwnd模式预测模型是在训练和测试样本大小比率的不同配置下评估的。==</p><ul><li><p>如上图所示，==我们发现了用于预测cwnd的基于RNN的模型可以非常准确地捕获cwnd下降的比率。==</p><blockquote><p>图6（a）和（b）没有共享相同的带宽，延迟，损耗和抖动配置，这会导致在连接过程中最大段数有所不同。例如，如果我们在图6（b）上看到，它的带宽延迟乘积（BDP）[17]为700mb * 0.01s = 875,000字节（logic here:这个和1500都是configuration）。在1500个字节段中，即583个段，而我们的仿真显示cwnd的最大段数为500-600。在下面显示的所有图中，==我们可以看到，一旦发生超时，响应3个重复的ACK，所有数据包丢失都会得到快速恢复。这是因为cwnd不会低于其先前峰值的一半。== 结果是，存在一个线性增加阶段，随后是一个丢包事件，其中cwnd随着新到达的ACK而增加。这也演示了TCP拥塞控制算法如何响应拥塞事件。</p></blockquote></li><li><p>我们还可以看到，预测的cwnd的模式通常与实际的cwnd非常匹配，并且预测误差很小。我们使用从内核获得的精确时间戳来匹配锯齿模式的增加部分和减少部分。</p><blockquote><p>We can see that the pattern of the predicted cwnd generally matches the actual cwnd quite well with a small prediction error. We matched both the increasing and decreasing parts of the sawtooth pattern using the precise timestamp obtained from the kernel.</p></blockquote></li></ul><h2 id="hesy-summary"><a href="#hesy-summary" class="headerlink" title="hesy summary"></a>hesy summary</h2><ul><li>对于基本的TCP变体预测任务，仅考虑了基于丢包的TCP拥塞控制算法(loss-based)</li><li>首创性(被动测量 中间节点 LSTM) 、 可扩展性 (scalable)</li><li>使用iperf制造数据包 使用tcptrace构建数据集</li></ul><h2 id="question"><a href="#question" class="headerlink" title="question"></a>question</h2><ul><li>Network Emulation Parameters中“但是，内核可能会将数据包的TCP每次连接状态保留在缓冲区中，并等待足够数量的数据包，然后再将TCP状态发送到用户空间。由于用户空间进程的TCP进程缓慢，TCP的每个连接状态也可能会丢失”不是很明白<ul><li>对应的==调整缓冲区大小并将缓冲区刷新到用户空间== 不是很明白这是在干什么<br>这两天找yanshu问下【！！！！】</li></ul></li><li>G. Assumptions 中的一些假设不是很懂在干什么 …. 目的何在？</li><li>使用tcptrace构建数据集指的应该是将检测到的信息里面的数据特征抽取出来？</li><li>仅考虑了基于丢包的TCP拥塞控制算法(loss-based)(e.g., CUBIC [9] BIC [32], and Reno [15]) –&gt; BIC是基于loss的么？？？</li><li>针对每个TCP做了36种配置，如表I所示，总共216种在实验(?咋算的..)</li><li>FIG6为什么跌破的时候没有跌到一半 反而比一半多一点<br>这个逻辑是什么<blockquote><p>我们可以看到，一旦发生超时，响应3个重复的ACK，所有数据包丢失都会得到快速恢复。这是因为cwnd不会低于其先前峰值的一半。<br>是后面是前面的现象的意思么 所以快恢复难道不是设置成一半么。。。</p></blockquote></li><li>这啥意思<blockquote><p>我们还可以看到，预测的cwnd的模式通常与实际的cwnd非常匹配，并且预测误差很小。我们使用从内核获得的精确时间戳来匹配锯齿模式的增加部分和减少部分。</p></blockquote></li></ul></div><footer class="post-footer"><div class="post-eof"></div></footer></article><article itemscope itemtype="http://schema.org/Article" class="post-block" lang="en,zh-CN,default"><link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/05/PaperReading/DeePCCI(SIGCOMM'19)/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/img/avatar-hexi.jpg"><meta itemprop="name" content="Hesy"><meta itemprop="description" content="some thoughts to share"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content="Hesy's Blog"></span><header class="post-header"><h2 class="post-title" itemprop="name headline"><a href="/2020/02/05/PaperReading/DeePCCI(SIGCOMM'19)/" class="post-title-link" itemprop="url">DeePCCI(SIGCOMM'19)</a></h2><div class="post-meta"><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar"></i> </span><span class="post-meta-item-text">Posted on</span> <time title="Created: 2020-02-05 12:00:00" itemprop="dateCreated datePublished" datetime="2020-02-05T12:00:00+08:00">2020-02-05</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-calendar-check"></i> </span><span class="post-meta-item-text">Edited on</span> <time title="Modified: 2020-07-30 22:25:40" itemprop="dateModified" datetime="2020-07-30T22:25:40+08:00">2020-07-30</time> </span><span class="post-meta-item"><span class="post-meta-item-icon"><i class="far fa-folder"></i> </span><span class="post-meta-item-text">In</span> <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/PaperReading/" itemprop="url" rel="index"><span itemprop="name">PaperReading</span></a></span></span><br><span class="post-meta-item" title="Symbols count in article"><span class="post-meta-item-icon"><i class="far fa-file-word"></i> </span><span class="post-meta-item-text">Symbols count in article: </span><span>3.8k</span> </span><span class="post-meta-item" title="Reading time"><span class="post-meta-item-icon"><i class="far fa-clock"></i> </span><span class="post-meta-item-text">Reading time &asymp;</span> <span>3 mins.</span></span></div></header><div class="post-body" itemprop="articleBody"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="introduction"><a href="#introduction" class="headerlink" title="introduction"></a>introduction</h1><blockquote><p>拥塞控制（CC）[12]是当今传输协议的基本组成部分，并强烈影响数据传输的性能。 CC最初建于1980年代以应对早期Internet的拥塞崩溃[17]，但CC仍在发展，并且出现了新的变体，例如BBR [1]或Vivace [3]。</p></blockquote><blockquote><p>CC引入了一个拥塞窗口（cwnd），该窗口限制了飞行中未确认字节的数量。==每种CC算法都定义了在特定算法定义的拥塞信号下，cwnd的变化情况==。给定CC方法的数量及其对性能的影响[9]，因此研究CC的使用方法很重要。例如，如果知道新的CC通常会与哪些其他算法竞争，则为公平起见，更容易对其进行调整。</p></blockquote><h2 id="传统的缺点"><a href="#传统的缺点" class="headerlink" title="传统的缺点"></a>传统的缺点</h2><blockquote><ul><li>但是，用于识别CC变体的现有工作（例如[2、18、24]）不适用于最新的CC和传输协议。==扩展和维护这些方法很复杂，因为它需要详细的领域知识才能知道CC参数化和配置如何影响其行为。== 当CC离开内核并引入用户空间协议（例如QUIC [11]）时，这一点变得尤为重要，这些协议相当容易更改，并且已经可以大规模部署[21]。</li></ul></blockquote><blockquote><ul><li>==此外，许多识别方法都基于fragile assumptions。== 例如，当使用TCP pacing （例如，与RENO [12]或CUBIC [5]结合使用）时，它们将失败。</li><li>*令人担忧的是，我们已知的所有被动方法都基于头部信息is parsable的的假设**。完全加密的传输（例如QUIC实施方案）使这些设计无效，并且如果可能的话，将需要进行重大更改。</li></ul></blockquote><p><strong>因此，目前就推理部署CC提出挑战。</strong></p><h2 id="难点与贡献"><a href="#难点与贡献" class="headerlink" title="难点与贡献"></a>难点与贡献</h2><p>作为应对这些挑战的第一步，本文介绍了DeePCCI，这是一种基于监督的基于深度学习的被动拥塞控制识别方法。<br>==它仅根据流数据包到达时间信息识别CC变体，因此甚至可以在加密的传输头上使用。==<br>此外，它使用深度学习来学习功能-从而避免了手动的，特定于领域的功能设计。<br>因此，与相关方法不同，==DeePCCI除了流分组定时的可用性之外，不做任何假设，== <strong>除了能够收集CC变体的训练流量之外，不需要任何领域知识。</strong><br>我们认为，这种假设和免手动调整方法允许在Internet流量中进行通用且可扩展的CC标识。具体来说，我们介绍DeePCCI的设计，评估及其局限性，并做出以下贡献：</p><p>•我们描述了流量的预处理和用于识别拥塞控制变量的深度学习模型。<br>•我们介绍了如何在测试平台上生成带有标记数据的多种拥塞控制变量模型。</p><p>我们评估了CUBIC，RENO和BBR作为主要拥塞控制变量的测试平台的性能。我们展示了该方法能够在各种情况下识别流量拥塞控制变量，但同时也介绍并讨论了无法识别拥塞控制变量的情况。结构体。第2节讨论了CC识别的最新技术及其缺点。第3节介绍DeePCCI的设计，而第4节介绍我们如何生成训练数据和评估我们的方法。最后，第5节总结了论文并讨论了未来的工作。</p><h1 id="related-work"><a href="#related-work" class="headerlink" title="related work"></a>related work</h1><blockquote><p>各种工作涉及识别CC变体。这些方法主要分为两类：使用被动[2、6、13、18、20]或主动[19、24]测量的识别方法。</p></blockquote><blockquote><p>主动方法可通过主动打开并操纵CC来激发CC反应进行检测。 Padhye和Floyd提出了TBIT [19]，该协议将精心制作的TCP段发送到Web服务器以主动触发拥塞控制。它记录响应丢失的数据包发送了哪些段，因为这种反应在TBIT中所区分的CC变体之间有很大差异。<br><br><br>杨等。目前的CAAI [24]扩展了TBIT的方法。为了估计发送方的cwnd，CAAI人为地延迟了观察所有飞行段的ACK。然后，CAAI导致数据包丢失，并从变化的cwnd中提取特征。这些功能随后用于使用随机森林进行分类。虽然这两种方法都可以实现较高的识别精度，但是由于错误选择的主机，因此依靠主动测量很容易引入测量偏差。<br><br><br>被动方法（与我们一样）不与主机交互，而是依靠流量跟踪来推断使用的流量CC变体，因此，它们允许收集有关实际流量的信息，该信息取决于有利位置而不是主动选择的主机。<br><br><br>Paxson等。和Jaiswal等。使用tcpanaly [20]和tcpflows [13]重建TCP状态机，以比较接收到的数据包和预期数据包。两种方法都需要非常详细的CC甚至实施知识来重建状态机。我们的方法的不同之处在于它不需要详细的CC知识。卡萨格兰德等。 [2]将cwnd中的特征更改用作其方法TCPMoon中的特征。针对这些功能检查了不同的手工规则，以区分CC。对于cwnd估计，作者使用基于TCP时间戳的RTT估计。因此，使用TCPMoon无法识别没有TCP时间戳选项或加密了传输头的流。由于我们的方法仅观察数据包到达的行为，因此不需要任何明文传输协议字段。<br><br><br>Oshio等。 [18]提出了一种基于聚类的方法。他们根据RTT估计值提取cwnd的特征并将其聚类以区分两个竞争的CC变体。我们的方法的不同之处在于，它不仅限于两个相互竞争的变体。哈戈斯等。<br><br><br>[6]使用发送方和接收方之间的未完成字节作为粗略且嘈杂的cwnd估计。使用递归神经网络对该估计值进行细化。精简后的Cwnd的突然减少用作CUBIC，BIC和RENO之间不同的乘法减少因子的估计。尽管此方法使用深度学习是相似的，但它仍然需要手动设计的乘数递减因子，因此只能识别基于损失的CC。我们的方法使用端到端深度学习模型，还识别基于延迟的CC并避免使用手动功能。</p></blockquote><h2 id="active-measurements"><a href="#active-measurements" class="headerlink" title="active measurements"></a>active measurements</h2><ul><li>制造丢包现象（ 通过延迟ack的发送或者是发送crafted packets to senders ）获得终端的变化情况<ul><li>获取了特征数据以后使用随机森林的方法</li></ul></li></ul><h2 id="passive-measurements"><a href="#passive-measurements" class="headerlink" title="passive measurements"></a>passive measurements</h2><ul><li>gather information on real traffic on vantage points ，而不是像active measurements那样观测主动选好的hosts</li><li>rebuild TCP state machine –》 需要detailed CC domain knowledge and implementation knowledge</li><li>建模去估计Cwnd changes –》 like 使用TCP的时间戳来估计RTT （ 加密了以后就不适用了</li></ul><p><br><br><br></p><h1 id="DeePCCI-design"><a href="#DeePCCI-design" class="headerlink" title="DeePCCI design"></a>DeePCCI design</h1><h2 id="CC-Manifestaion-in-Traffic"><a href="#CC-Manifestaion-in-Traffic" class="headerlink" title="CC Manifestaion in Traffic"></a>CC Manifestaion in Traffic</h2><ul><li>only use <strong>arrival time</strong> of a flow as input<ul><li>unlike Netflow 是什么意思 ？ Netflow没有packet timing嘛</li><li>目的 :associate packets to flow</li></ul></li></ul><h2 id="Architecture"><a href="#Architecture" class="headerlink" title="Architecture"></a>Architecture</h2><p><img src="https://images.weserv.nl/?url=https://img-blog.csdnimg.cn/20190924094304705.png" alt="在这里插入图片描述"></p><h3 id="CNN"><a href="#CNN" class="headerlink" title="CNN"></a>CNN</h3><ul><li>用于特征提取</li><li>改进了VGG net 结合了 residual network</li></ul><h3 id="LSTM"><a href="#LSTM" class="headerlink" title="LSTM"></a>LSTM</h3><ul><li>如果packet的size是固定的，就用VGGNet就够了 ，但是由于我们想看的是length-variant的packet，所以使用LSTM–》有记忆<ul><li>用的是unidirectional network</li></ul></li></ul><p><br><br><br></p><h1 id="Experimental-setup"><a href="#Experimental-setup" class="headerlink" title="Experimental setup"></a>Experimental setup</h1><h2 id="Mininet-based-Network-Testbed"><a href="#Mininet-based-Network-Testbed" class="headerlink" title="Mininet-based Network Testbed"></a>Mininet-based Network Testbed</h2><ul><li>不同的网络环境<ul><li>TCP sender number</li><li>link latency</li><li>bottleneck link’s BDP</li></ul></li><li>选择了三个variant进行对比 ( RENO, CUBIC ,BBR )<ul><li>每个发送60s 的fully-loaded TCP stream</li><li>观测者比发送者早2s开启</li></ul></li></ul><h2 id="Single-Host-Network"><a href="#Single-Host-Network" class="headerlink" title="Single-Host Network"></a>Single-Host Network</h2><ul><li><strong>baseline condition</strong></li><li>哑铃状拓扑</li><li>没有背景流量</li></ul><h2 id="Multi-Host-Network"><a href="#Multi-Host-Network" class="headerlink" title="Multi-Host Network"></a>Multi-Host Network</h2><ul><li>reside on each side of the network</li></ul><h2 id="Cross-Traffic-Network"><a href="#Cross-Traffic-Network" class="headerlink" title="Cross-Traffic Network"></a>Cross-Traffic Network</h2><ul><li>side flow</li><li>main flow</li></ul><h2 id="performance"><a href="#performance" class="headerlink" title="performance"></a>performance</h2><h3 id="identifacation-by-Delay-and-Bandwidth"><a href="#identifacation-by-Delay-and-Bandwidth" class="headerlink" title="identifacation by Delay and Bandwidth"></a>identifacation by Delay and Bandwidth</h3><h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><ul><li>带宽越大、延迟越大、host越多越容易识别成功</li></ul><h4 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h4><ul><li><p>带宽越大越成功是因为</p><ul><li>归因于拥塞窗口的整数离散化，而最大cwnd取决于瓶颈带宽。 ( 我的理解就是：允许的cc窗口的区别度高 ）</li><li>以较大的带宽采样了诸如CUBIC的cubic行为的更多步骤。 较低的带宽意味着较少的采样步骤，并且三次行为很难与例如RENO的线性行为相区别。</li></ul></li><li><p>认为延迟越大越成功</p><ul><li>与histogram的bin-size 有关<blockquote><p>我个人在这里的理解就是： bin-size 就有点像分辨率 如果延迟太小，会导致整个图被横向压扁；如果延迟大一点，整个图就会舒展开，一些特征啥的会更加清晰，容易被CNN识别、提取到<br>有点意思 :)</p></blockquote></li></ul></li><li><p>认为多主机效果更好是因为</p><ul><li>对于相同的延迟，多主机情况也能获得更好的结果。我们将此影响归因于流量竞争。当link饱和时，单主机流的速率不会随着cwnd的增加而迅速增加，<strong>但是在多主机方案中增加流的cwnd可以增加其在队列中的数据包的份额，从而增加其速率。</strong> <strong>因此，对不同拥塞控制变量的cwnd的单独更改会对速率产生更大的影响，从而更强烈地影响数据包到达</strong>，并在更长的时间内影响较小的延迟和带宽问题。</li></ul></li></ul><p><strong>【感觉这一点实际上是利用了这三种方案面对竞争时候的特性有所区别的特点，并不是说：Competing的时候会有种让CC增加cwnd的动力(只有发的多才能收的快 收的快才能滑动) ，而应该说：面对 competing的时候有不同的特性，有的人会趋于让cwnd增大，所以对应的包发得多，到达的间隔就短了】</strong></p><blockquote><p>如我们所见，<strong>带宽和延迟会影响我们的方法</strong>，延迟/带宽过小会导致识别性能降低。<strong>为了进一步评估，我们将以50Mbps作为带宽</strong>继续进行实验，以更好地了解该方法在何处面临挑战。</p></blockquote></div><footer class="post-footer"><div class="post-eof"></div></footer></article></div><script>window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }</script></div></main><footer class="footer"><div class="footer-inner"><div class="languages"><label class="lang-select-label"><i class="fa fa-language"></i> <span>English</span> <i class="fa fa-angle-up" aria-hidden="true"></i></label> <select class="lang-select" data-canonical=""><option value="en" data-href="/index.html" selected>English</option><option value="zh-CN" data-href="/zh-CN/index.html" selected>简体中文</option></select></div><div class="copyright">&copy; <span itemprop="copyrightYear">2020</span> <span class="with-love"><i class="fa fa-heart"></i> </span><span class="author" itemprop="copyrightHolder">Hesy</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-chart-area"></i> </span><span title="Symbols count total">16k</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="fa fa-coffee"></i> </span><span title="Reading time total">15 mins.</span></div><div class="powered-by">Powered by <span class="exturl theme-link" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & <span class="exturl theme-link" data-url="aHR0cHM6Ly90aGVtZS1uZXh0LmpzLm9yZw==">NexT.Gemini</span></div></div></footer></div><script src="//js.njzjz.win/npm/animejs@3.1.0/lib/anime.min.js"></script><script src="//js.njzjz.win/npm/velocity-animate@1/velocity.min.js"></script><script src="//js.njzjz.win/npm/velocity-animate@1/velocity.ui.min.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script><script src="/js/local-search.js"></script><script>document.querySelectorAll('.pdfobject-container').forEach(element => {
  let url = element.dataset.target;
  let pdfOpenParams = {
    navpanes : 0,
    toolbar  : 0,
    statusbar: 0,
    pagemode : 'thumbs',
    view     : 'FitH'
  };
  let pdfOpenFragment = '#' + Object.entries(pdfOpenParams).map(([key, value]) => `${key}=${encodeURIComponent(value)}`).join('&');
  let fullURL = `/lib/pdf/web/viewer.html?file=${encodeURIComponent(url)}${pdfOpenFragment}`;

  if (NexT.utils.supportsPDFs()) {
    element.innerHTML = `<embed class="pdfobject" src="${url + pdfOpenFragment}" type="application/pdf" style="height: ${element.dataset.height};">`;
  } else {
    element.innerHTML = `<iframe src="${fullURL}" style="height: ${element.dataset.height};" frameborder="0"></iframe>`;
  }
});</script></body></html>